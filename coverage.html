
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>netconf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">nemith.io/netconf/capability.go (83.3%)</option>
				
				<option value="file1">nemith.io/netconf/msg.go (33.3%)</option>
				
				<option value="file2">nemith.io/netconf/ops.go (93.6%)</option>
				
				<option value="file3">nemith.io/netconf/session.go (52.9%)</option>
				
				<option value="file4">nemith.io/netconf/transport/frame.go (59.2%)</option>
				
				<option value="file5">nemith.io/netconf/transport/ssh/ssh.go (66.7%)</option>
				
				<option value="file6">nemith.io/netconf/transport/tls/tls.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package netconf

const (
        baseCap      = "urn:ietf:params:netconf:base"
        stdCapPrefix = "urn:ietf:params:netconf:capability"
)

// DefaultCapabilities are the capabilities sent by the client during the hello
// exchange by the server.
var DefaultCapabilities = []string{
        "urn:ietf:params:netconf:base:1.0",
        "urn:ietf:params:netconf:base:1.1",

        // XXX: these seems like server capabilities and i don't see why
        // a client would need to send them

        // "urn:ietf:params:netconf:capability:writable-running:1.0",
        // "urn:ietf:params:netconf:capability:candidate:1.0",
        // "urn:ietf:params:netconf:capability:confirmed-commit:1.0",
        // "urn:ietf:params:netconf:capability:rollback-on-error:1.0",
        // "urn:ietf:params:netconf:capability:startup:1.0",
        // "urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp",
        // "urn:ietf:params:netconf:capability:validate:1.0",
        // "urn:ietf:params:netconf:capability:xpath:1.0",
        // "urn:ietf:params:netconf:capability:notification:1.0",
        // "urn:ietf:params:netconf:capability:interleave:1.0",
        // "urn:ietf:params:netconf:capability:with-defaults:1.0",
}

// ExpandCapability will automatically add the standard capability prefix of
// `urn:ietf:params:netconf:capability` if not already present.
func ExpandCapability(s string) string <span class="cov10" title="52">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov10" title="52">if s[0] != ':' </span><span class="cov10" title="52">{
                return s
        }</span>

        <span class="cov0" title="0">return stdCapPrefix + s</span>
}

// XXX: may want to expose this type publicly in the future when the api has
// stabilized?
type capabilitySet struct {
        caps map[string]struct{}
}

func newCapabilitySet(capabilities ...string) capabilitySet <span class="cov8" title="25">{
        cs := capabilitySet{
                caps: make(map[string]struct{}),
        }
        cs.Add(capabilities...)
        return cs
}</span>

func (cs *capabilitySet) Add(capabilities ...string) <span class="cov8" title="25">{
        for _, cap := range capabilities </span><span class="cov9" title="50">{
                cap = ExpandCapability(cap)
                cs.caps[cap] = struct{}{}
        }</span>
}

func (cs capabilitySet) Has(s string) bool <span class="cov2" title="2">{
        // XXX: need to figure out how to handle versions (i.e always map to 1.0 or
        // map to latest/any?)
        s = ExpandCapability(s)
        _, ok := cs.caps[s]
        return ok
}</span>

func (cs capabilitySet) All() []string <span class="cov4" title="4">{
        out := make([]string, 0, len(cs.caps))
        for cap := range cs.caps </span><span class="cov0" title="0">{
                out = append(out, cap)
        }</span>
        <span class="cov4" title="4">return out</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package netconf

import (
        "encoding/xml"
        "fmt"
        "strings"
        "time"

        "golang.org/x/exp/slices"
)

// RawXML captures the raw xml for the given element.  Used to process certain
// elements later.
type RawXML []byte

func (x *RawXML) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov4" title="4">{
        var inner struct {
                Data []byte `xml:",innerxml"`
        }

        if err := d.DecodeElement(&amp;inner, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="4">*x = inner.Data
        return nil</span>
}

// MarshalXML implements xml.Marshaller.  Raw XML is passed verbatim, errors and
// all.
func (x *RawXML) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov4" title="4">{
        inner := struct {
                Data []byte `xml:",innerxml"`
        }{
                Data: []byte(*x),
        }
        return e.EncodeElement(&amp;inner, start)
}</span>

// helloMsg maps the xml value of the &lt;hello&gt; message in RFC6241
type helloMsg struct {
        XMLName      xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 hello"`
        SessionID    uint64   `xml:"session-id,omitempty"`
        Capabilities []string `xml:"capabilities&gt;capability"`
}

// request maps the xml value of &lt;rpc&gt; in RFC6241
type request struct {
        XMLName   xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc"`
        MessageID uint64   `xml:"message-id,attr"`
        Operation any      `xml:",innerxml"`
}

func (msg *request) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov10" title="29">{
        if msg.Operation == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("operation cannot be nil")
        }</span>

        // TODO: validate operation is named?

        // alias the type to not cause recursion calling e.Encode
        <span class="cov9" title="28">type rpcMsg request
        inner := rpcMsg(*msg)
        return e.Encode(&amp;inner)</span>
}

// Reply maps the xml value of &lt;rpc-reply&gt; in RFC6241
type Reply struct {
        XMLName   xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc-reply"`
        MessageID uint64    `xml:"message-id,attr"`
        Errors    RPCErrors `xml:"rpc-error,omitempty"`
        Body      []byte    `xml:",innerxml"`
}

// Decode will decode the body of a reply into a value pointed to by v.  This is
// a simple wrapper around xml.Unmarshal.
func (r Reply) Decode(v interface{}) error <span class="cov9" title="24">{
        return xml.Unmarshal(r.Body, v)
}</span>

// Err will return go error(s) from a Reply that are of the given severities. If
// no severity is given then it defaults to `ErrSevError`.
//
// If one error is present then the underlyign type is `RPCError`. If more than
// one error exists than the underlying type is `[]RPCError`
//
// Example

// get all errors with severity of error
//
//        if err := reply.Err(ErrSevError); err != nil { /* ... */ }
//
// or
//
//        if err := reply.Err(); err != nil { /* ... */ }
//
// get all errors with severity of only warning
//
//        if err := reply.Err(ErrSevWarning); err != nil { /* ... */ }
//
// get all errors
//
//        if err := reply.Err(ErrSevWarning, ErrSevError); err != nil { /* ... */ }
func (r Reply) Err(severity ...ErrSeverity) error <span class="cov9" title="24">{
        // fast escape for no errors
        if len(r.Errors) == 0 </span><span class="cov9" title="24">{
                return nil
        }</span>

        <span class="cov0" title="0">errs := r.Errors.Filter(severity...)
        switch len(errs) </span>{
        case 0:<span class="cov0" title="0">
                return nil</span>
        case 1:<span class="cov0" title="0">
                return errs[0]</span>
        default:<span class="cov0" title="0">
                return errs</span>
        }
}

type Notification struct {
        XMLName   xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:notification:1.0 notification"`
        EventTime time.Time `xml:"eventTime"`
        Body      []byte    `xml:",innerxml"`
}

// Decode will decode the body of a noticiation into a value pointed to by v.
// This is a simple wrapper around xml.Unmarshal.
func (r Notification) Decode(v interface{}) error <span class="cov0" title="0">{
        return xml.Unmarshal(r.Body, v)
}</span>

type ErrSeverity string

const (
        SevError   ErrSeverity = "error"
        SevWarning ErrSeverity = "warning"
)

type ErrType string

const (
        ErrTypeTransport ErrType = "transport"
        ErrTypeRPC       ErrType = "rpc"
        ErrTypeProtocol  ErrType = "protocol"
        ErrTypeApp       ErrType = "app"
)

type ErrTag string

const (
        ErrInUse                 ErrTag = "in-use"
        ErrInvalidValue          ErrTag = "invalid-value"
        ErrTooBig                ErrTag = "too-big"
        ErrMissingAttribute      ErrTag = "missing-attribute"
        ErrBadAttribute          ErrTag = "bad-attribute"
        ErrUnknownAttribute      ErrTag = "unknown-attribute"
        ErrMissingElement        ErrTag = "missing-element"
        ErrBadElement            ErrTag = "bad-element"
        ErrUnknownElement        ErrTag = "unknown-element"
        ErrUnknownNamespace      ErrTag = "unknown-namespace"
        ErrAccesDenied           ErrTag = "access-denied"
        ErrLockDenied            ErrTag = "lock-denied"
        ErrResourceDenied        ErrTag = "resource-denied"
        ErrRollbackFailed        ErrTag = "rollback-failed"
        ErrDataExists            ErrTag = "data-exists"
        ErrDataMissing           ErrTag = "data-missing"
        ErrOperationNotSupported ErrTag = "operation-not-supported"
        ErrOperationFailed       ErrTag = "operation-failed"
        ErrPartialOperation      ErrTag = "partial-operation"
        ErrMalformedMessage      ErrTag = "malformed-message"
)

type RPCError struct {
        Type     ErrType     `xml:"error-type"`
        Tag      ErrTag      `xml:"error-tag"`
        Severity ErrSeverity `xml:"error-severity"`
        AppTag   string      `xml:"error-app-tag,omitempty"`
        Path     string      `xml:"error-path,omitempty"`
        Message  string      `xml:"error-message,omitempty"`
        Info     RawXML      `xml:"error-info,omitempty"`
}

func (e RPCError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("netconf error: %s %s: %s", e.Type, e.Tag, e.Message)
}</span>

type RPCErrors []RPCError

func (errs RPCErrors) Filter(severity ...ErrSeverity) RPCErrors <span class="cov0" title="0">{
        if len(errs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(severity) == 0 </span><span class="cov0" title="0">{
                severity = []ErrSeverity{SevError}
        }</span>

        <span class="cov0" title="0">filteredErrs := make(RPCErrors, 0, len(errs))
        for _, err := range errs </span><span class="cov0" title="0">{
                if !slices.Contains(severity, err.Severity) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filteredErrs = append(filteredErrs, err)</span>
        }
        <span class="cov0" title="0">return filteredErrs</span>
}

func (errs RPCErrors) Error() string <span class="cov0" title="0">{
        var sb strings.Builder
        for i, err := range errs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteRune('\n')
                }</span>
                <span class="cov0" title="0">sb.WriteString(err.Error())</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

func (errs RPCErrors) Unwrap() []error <span class="cov0" title="0">{
        boxedErrs := make([]error, len(errs))
        for i, err := range errs </span><span class="cov0" title="0">{
                boxedErrs[i] = err
        }</span>
        <span class="cov0" title="0">return boxedErrs</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "fmt"
        "strings"
        "time"
)

type ExtantBool bool

func (b ExtantBool) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov4" title="3">{
        if !b </span><span class="cov0" title="0">{
                return nil
        }</span>
        // This produces a empty start/end tag (i.e &lt;tag&gt;&lt;/tag&gt;) vs a self-closing
        // tag (&lt;tag/&gt;() which should be the same in XML, however I know certain
        // vendors may have issues with this format. We may have to process this
        // after xml encoding.
        //
        // See https://github.com/golang/go/issues/21399
        // or https://github.com/golang/go/issues/26756 for a different hack.
        <span class="cov4" title="3">return e.EncodeElement(struct{}{}, start)</span>
}

func (b *ExtantBool) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov3" title="2">{
        v := &amp;struct{}{}
        if err := d.DecodeElement(v, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">*b = v != nil
        return nil</span>
}

type OKResp struct {
        OK ExtantBool `xml:"ok"`
}

type Datastore string

func (s Datastore) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov10" title="20">{
        if s == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("datastores cannot be empty")
        }</span>

        // XXX: it would be nice to actually just block names with crap in them
        // instead of escaping them, but we need to find a list of what is allowed
        // in an xml tag.
        <span class="cov9" title="19">escaped, err := escapeXML(string(s))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid string element: %w", err)
        }</span>

        <span class="cov9" title="19">v := struct {
                Elem string `xml:",innerxml"`
        }{Elem: "&lt;" + escaped + "/&gt;"}
        return e.EncodeElement(&amp;v, start)</span>
}

func escapeXML(input string) (string, error) <span class="cov9" title="19">{
        buf := &amp;strings.Builder{}
        if err := xml.EscapeText(buf, []byte(input)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov9" title="19">return buf.String(), nil</span>
}

type URL string

func (u URL) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov3" title="2">{
        v := struct {
                URL string `xml:"url"`
        }{string(u)}
        return e.EncodeElement(&amp;v, start)
}</span>

const (
        // Running configuration datastore. Required by RFC6241
        Running Datastore = "running"

        // Candidate configuration configuration datastore.  Supported with the
        // `:candidate` capability defined in RFC6241 section 8.3
        Candidate Datastore = "candidate"

        // Startup configuration configuration datastore.  Supported with the
        // `:startup` capability defined in RFC6241 section 8.7
        Startup Datastore = "startup" //
)

type GetConfigReq struct {
        XMLName xml.Name  `xml:"get-config"`
        Source  Datastore `xml:"source"`
        // Filter
}

type GetConfigReply struct {
        XMLName xml.Name `xml:"data"`
        Config  []byte   `xml:",innerxml"`
}

// GetConfig implements the &lt;get-config&gt; rpc operation defined in [RFC6241 7.1].
// `source` is the datastore to query.
//
// [RFC6241 7.1]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.1
func (s *Session) GetConfig(ctx context.Context, source Datastore) ([]byte, error) <span class="cov1" title="1">{
        req := GetConfigReq{
                Source: source,
        }

        var resp GetConfigReply
        if err := s.Call(ctx, &amp;req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Config, nil</span>
}

// MergeStrategy defines the strategies for merging configuration in a
// `&lt;edit-config&gt; operation`.
//
// *Note*: in RFC6241 7.2 this is called the `operation` attribute and
// `default-operation` parameter.  Since the `operation` term is already
// overloaded this was changed to `MergeStrategy` for a cleaner API.
type MergeStrategy string

const (
        // MergeConfig configuration elements are merged together at the level at
        // which this specified.  Can be used for config elements as well as default
        // defined with [WithDefaultMergeStrategy] option.
        MergeConfig MergeStrategy = "merge"

        // ReplaceConfig defines that the incoming config change should replace the
        // existing config at the level which it is specified.  This can be
        // specified on individual config elements or set as the default strategy set
        // with [WithDefaultMergeStrategy] option.
        ReplaceConfig MergeStrategy = "replace"

        // NoMergeStrategy is only used as a default strategy defined in
        // [WithDefaultMergeStrategy].  Elements must specific one of the other
        // strategies with the `operation` Attribute on elements in the `&lt;config&gt;`
        // subtree.  Elements without the `operation` attribute are ignored.
        NoMergeStrategy MergeStrategy = "none"

        // CreateConfig allows a subtree element to be created only if it doesn't
        // already exist.
        // This strategy is only used as the `operation` attribute of
        // a `&lt;config&gt;` element and cannot be used as the default strategy.
        CreateConfig MergeStrategy = "create"

        // DeleteConfig will completely delete subtree from the config only if it
        // already exists.  This strategy is only used as the `operation` attribute
        // of a `&lt;config&gt;` element and cannot be used as the default strategy.
        DeleteConfig MergeStrategy = "delete"

        // RemoveConfig will remove subtree from the config.  If the subtree doesn't
        // exist in the datastore then it is silently skipped.  This strategy is
        // only used as the `operation` attribute of a `&lt;config&gt;` element and cannot
        // be used as the default strategy.
        RemoveConfig MergeStrategy = "remove"
)

// TestStrategy defines the beahvior for testing configuration before applying it in a `&lt;edit-config&gt;` operation.
//
// *Note*: in RFC6241 7.2 this is called the `test-option` parameter. Since the `option` term is already
// overloaded this was changed to `TestStrategy` for a cleaner API.
type TestStrategy string

const (
        // TestThenSet will validate the configuration and only if is is valid then
        // apply the configuration to the datastore.
        TestThenSet TestStrategy = "test-then-set"

        // SetOnly will not do any testing before applying it.
        SetOnly TestStrategy = "set"

        // Test only will validation the incoming configuration and return the
        // results without modifying the underlying store.
        TestOnly TestStrategy = "test-only"
)

// ErrorStrategy defines the behavior when an error is encountered during a `&lt;edit-config&gt;` operation.
//
// *Note*: in RFC6241 7.2 this is called the `error-option` parameter. Since the `option` term is already
// overloaded this was changed to `ErrorStrategy` for a cleaner API.
type ErrorStrategy string

const (
        // StopOnError will about the `&lt;edit-config&gt;` operation on the first error.
        StopOnError ErrorStrategy = "stop-on-error"

        // ContinueOnError will continue to parse the configuration data even if an
        // error is encountered.  Errors are still recorded and reported in the
        // reply.
        ContinueOnError ErrorStrategy = "continue-on-error"

        // RollbackOnError will restore the configuration back to before the
        // `&lt;edit-config&gt;` operation took place.  This requires the device to
        // support the `:rollback-on-error` capabilitiy.
        RollbackOnError ErrorStrategy = "rollback-on-error"
)

type (
        defaultMergeStrategy MergeStrategy
        testStrategy         TestStrategy
        errorStrategy        ErrorStrategy
)

func (o defaultMergeStrategy) apply(req *EditConfigReq) <span class="cov1" title="1">{ req.DefaultMergeStrategy = MergeStrategy(o) }</span>
func (o testStrategy) apply(req *EditConfigReq)         <span class="cov1" title="1">{ req.TestStrategy = TestStrategy(o) }</span>
func (o errorStrategy) apply(req *EditConfigReq)        <span class="cov1" title="1">{ req.ErrorStrategy = ErrorStrategy(o) }</span>

// WithDefaultMergeStrategy sets the default config merging strategy for the
// &lt;edit-config&gt; operation.  Only [Merge], [Replace], and [None] are supported
// (the rest of the strategies are for defining as attributed in individual
// elements inside the `&lt;config&gt;` subtree).
func WithDefaultMergeStrategy(op MergeStrategy) EditConfigOption <span class="cov1" title="1">{ return defaultMergeStrategy(op) }</span>

// WithTestStrategy sets the `test-option` in the `&lt;edit-config&gt;â€œ operation.
// This defines what testing should be done the supplied configuration.  See the
// documentation on [TestStrategy] for details on each strategy.
func WithTestStrategy(op TestStrategy) EditConfigOption <span class="cov1" title="1">{ return testStrategy(op) }</span>

// WithErrorStrategy sets the `error-option` in the `&lt;edit-config&gt;` operation.
// This defines the behavior when errors are encountered applying the supplied
// config.  See [ErrorStrategy] for the available options.
func WithErrorStrategy(opt ErrorStrategy) EditConfigOption <span class="cov1" title="1">{ return errorStrategy(opt) }</span>

type EditConfigReq struct {
        XMLName              xml.Name      `xml:"edit-config"`
        Target               Datastore     `xml:"target"`
        DefaultMergeStrategy MergeStrategy `xml:"default-operation,omitempty"`
        TestStrategy         TestStrategy  `xml:"test-option,omitempty"`
        ErrorStrategy        ErrorStrategy `xml:"error-option,omitempty"`

        // either of these two values
        Config any    `xml:"config,omitempty"`
        URL    string `xml:"url,omitempty"`
}

// EditOption is a optional arguments to [Session.EditConfig] method
type EditConfigOption interface {
        apply(*EditConfigReq)
}

// EditConfig issues the `&lt;edit-config&gt;` operation defined in [RFC6241 7.2] for
// updating an existing target config datastore.
//
// [RFC6241 7.2]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.2
func (s *Session) EditConfig(ctx context.Context, target Datastore, config any, opts ...EditConfigOption) error <span class="cov5" title="4">{
        req := EditConfigReq{
                Target: target,
        }

        // XXX: Should we use reflect here?
        switch v := config.(type) </span>{
        case string:<span class="cov1" title="1">
                req.Config = struct {
                        Inner []byte `xml:",innerxml"`
                }{Inner: []byte(v)}</span>
        case []byte:<span class="cov1" title="1">
                req.Config = struct {
                        Inner []byte `xml:",innerxml"`
                }{Inner: v}</span>
        case URL:<span class="cov1" title="1">
                req.URL = string(v)</span>
        default:<span class="cov1" title="1">
                req.Config = config</span>
        }

        <span class="cov5" title="4">for _, opt := range opts </span><span class="cov4" title="3">{
                opt.apply(&amp;req)
        }</span>

        <span class="cov5" title="4">var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)</span>
}

type CopyConfigReq struct {
        XMLName xml.Name `xml:"copy-config"`
        Source  any      `xml:"source"`
        Target  any      `xml:"target"`
}

// CopyConfig issues the `&lt;copy-config&gt;` operation as defined in [RFC6241 7.3]
// for copying an entire config to/from a source and target datastore.
//
// A `&lt;config&gt;` element defining a full config can be used as the source.
//
// If a device supports the `:url` capability than a [URL] object can be used
// for the source or target datastore.
//
// [RFC6241 7.3] https://www.rfc-editor.org/rfc/rfc6241.html#section-7.3
func (s *Session) CopyConfig(ctx context.Context, source, target any) error <span class="cov4" title="3">{
        req := CopyConfigReq{
                Source: source,
                Target: target,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type DeleteConfigReq struct {
        XMLName xml.Name  `xml:"delete-config"`
        Target  Datastore `xml:"target"`
}

func (s *Session) DeleteConfig(ctx context.Context, target Datastore) error <span class="cov1" title="1">{
        req := DeleteConfigReq{
                Target: target,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type LockReq struct {
        XMLName xml.Name
        Target  Datastore `xml:"target"`
}

func (s *Session) Lock(ctx context.Context, target Datastore) error <span class="cov1" title="1">{
        req := LockReq{
                XMLName: xml.Name{Space: "urn:ietf:params:xml:ns:netconf:base:1.0", Local: "lock"},
                Target:  target,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

func (s *Session) Unlock(ctx context.Context, target Datastore) error <span class="cov1" title="1">{
        req := LockReq{
                XMLName: xml.Name{Space: "urn:ietf:params:xml:ns:netconf:base:1.0", Local: "unlock"},
                Target:  target,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

/*
func (s *Session) Get(ctx context.Context,  filter Filter) error {
        panic("unimplemented")
}
*/

type KillSessionReq struct {
        XMLName   xml.Name `xml:"kill-session"`
        SessionID uint32   `xml:"session-id"`
}

func (s *Session) KillSession(ctx context.Context, sessionID uint32) error <span class="cov1" title="1">{
        req := KillSessionReq{
                SessionID: sessionID,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type ValidateReq struct {
        XMLName xml.Name `xml:"validate"`
        Source  any      `xml:"source"`
}

func (s *Session) Validate(ctx context.Context, source any) error <span class="cov1" title="1">{
        req := ValidateReq{
                Source: source,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type CommitReq struct {
        XMLName        xml.Name   `xml:"commit"`
        Confirmed      ExtantBool `xml:"confirmed,omitempty"`
        ConfirmTimeout int64      `xml:"confirm-timeout,omitempty"`
        Persist        string     `xml:"persist,omitempty"`
        PersistID      string     `xml:"persist-id,omitempty"`
}

// CommitOption is a optional arguments to [Session.Commit] method
type CommitOption interface {
        apply(*CommitReq)
}

type confirmed bool
type confirmedTimeout struct {
        time.Duration
}
type persist string
type persistID string

func (o confirmed) apply(req *CommitReq) <span class="cov1" title="1">{ req.Confirmed = true }</span>
func (o confirmedTimeout) apply(req *CommitReq) <span class="cov1" title="1">{
        req.Confirmed = true
        req.ConfirmTimeout = int64(o.Seconds())
}</span>
func (o persist) apply(req *CommitReq) <span class="cov1" title="1">{
        req.Confirmed = true
        req.Persist = string(o)
}</span>
func (o persistID) apply(req *CommitReq) <span class="cov1" title="1">{ req.PersistID = string(o) }</span>

// RollbackOnError will restore the configuration back to before the
// `&lt;edit-config&gt;` operation took place.  This requires the device to
// support the `:rollback-on-error` capability.

// WithConfirmed will mark the commits as requiring confirmation or will rollback
// after the default timeout on the device (default should be 600s).  The commit
// can be confirmed with another `&lt;commit&gt;` call without the confirmed option,
// extended by calling with `Commit` With `WithConfirmed` or
// `WithConfirmedTimeout` or canceling the commit with a `CommitCancel` call.
// This requires the device to support the `:confirmed-commit:1.1` capability.
func WithConfirmed() CommitOption <span class="cov1" title="1">{ return confirmed(true) }</span>

// WithConfirmedTimeout is like `WithConfirmed` but using the given timeout
// duration instead of the device's default.
func WithConfirmedTimeout(timeout time.Duration) CommitOption <span class="cov1" title="1">{ return confirmedTimeout{timeout} }</span>

// WithPersist allows you to set a identifier to confirm a commit in another
// sessions.  Confirming the commit requires setting the `WithPersistID` in the
// following `Commit` call matching the id set on the confirmed commit.  Will
// mark the commit as confirmed if not already set.
func WithPersist(id string) CommitOption <span class="cov1" title="1">{ return persist(id) }</span>

// WithPersistID is used to confirm a previous commit set with a given
// identifier.  This allows you to confirm a commit from (potentially) another
// sesssion.
func WithPersistID(id string) persistID <span class="cov3" title="2">{ return persistID(id) }</span>

// Commit will commit a canidate config to the running comming. This requires
// the device to support the `:canidate` capability.
func (s *Session) Commit(ctx context.Context, opts ...CommitOption) error <span class="cov5" title="5">{
        var req CommitReq
        for _, opt := range opts </span><span class="cov5" title="4">{
                opt.apply(&amp;req)
        }</span>

        <span class="cov5" title="5">if req.PersistID != "" &amp;&amp; req.Confirmed </span><span class="cov0" title="0">{
                return fmt.Errorf("PersistID cannot be used with Confirmed/ConfirmedTimeout or Persist options")
        }</span>

        <span class="cov5" title="5">var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)</span>
}

// CancelCommitOption is a optional arguments to [Session.CancelCommit] method
type CancelCommitOption interface {
        applyCancelCommit(*CancelCommitReq)
}

func (o persistID) applyCancelCommit(req *CancelCommitReq) <span class="cov1" title="1">{ req.PersistID = string(o) }</span>

type CancelCommitReq struct {
        XMLName   xml.Name `xml:"cancel-commit"`
        PersistID string   `xml:"persist-id,omitempty"`
}

func (s *Session) CancelCommit(ctx context.Context, opts ...CancelCommitOption) error <span class="cov3" title="2">{
        var req CancelCommitReq
        for _, opt := range opts </span><span class="cov1" title="1">{
                opt.applyCancelCommit(&amp;req)
        }</span>

        <span class="cov3" title="2">var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)</span>
}

// CreateSubscriptionOption is a optional arguments to [Session.CreateSubscription] method
type CreateSubscriptionOption interface {
        apply(req *CreateSubscriptionReq)
}

type CreateSubscriptionReq struct {
        XMLName xml.Name `xml:"urn:ietf:params:xml:ns:netconf:notification:1.0 create-subscription"`
        Stream  string   `xml:"stream,omitempty"`
        // TODO: Implement filter
        //Filter    int64    `xml:"filter,omitempty"`
        StartTime string `xml:"startTime,omitempty"`
        EndTime   string `xml:"endTime,omitempty"`
}

type stream string
type startTime time.Time
type endTime time.Time

func (o stream) apply(req *CreateSubscriptionReq) <span class="cov1" title="1">{
        req.Stream = string(o)
}</span>
func (o startTime) apply(req *CreateSubscriptionReq) <span class="cov1" title="1">{
        req.StartTime = time.Time(o).Format(time.RFC3339)
}</span>
func (o endTime) apply(req *CreateSubscriptionReq) <span class="cov1" title="1">{
        req.EndTime = time.Time(o).Format(time.RFC3339)
}</span>

func WithStreamOption(s string) CreateSubscriptionOption        <span class="cov1" title="1">{ return stream(s) }</span>
func WithStartTimeOption(st time.Time) CreateSubscriptionOption <span class="cov1" title="1">{ return startTime(st) }</span>
func WithEndTimeOption(et time.Time) CreateSubscriptionOption   <span class="cov1" title="1">{ return endTime(et) }</span>

func (s *Session) CreateSubscription(ctx context.Context, opts ...CreateSubscriptionOption) error <span class="cov5" title="4">{
        var req CreateSubscriptionReq
        for _, opt := range opts </span><span class="cov4" title="3">{
                opt.apply(&amp;req)
        }</span>
        // TODO: eventual custom notifications rpc logic, e.g. create subscription only if notification capability is present

        <span class="cov5" title="4">var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "sync"
        "sync/atomic"
        "syscall"

        "nemith.io/netconf/transport"
)

var ErrClosed = errors.New("closed connection")

type sessionConfig struct {
        capabilities        []string
        notificationHandler NotificationHandler
}

type SessionOption interface {
        apply(*sessionConfig)
}

type capabilityOpt []string

func (o capabilityOpt) apply(cfg *sessionConfig) <span class="cov0" title="0">{
        for _, cap := range o </span><span class="cov0" title="0">{
                cfg.capabilities = append(cfg.capabilities, cap)
        }</span>
}

func WithCapability(capabilities ...string) SessionOption <span class="cov0" title="0">{
        return capabilityOpt(capabilities)
}</span>

type notificationHandlerOpt NotificationHandler

func (o notificationHandlerOpt) apply(cfg *sessionConfig) <span class="cov0" title="0">{
        cfg.notificationHandler = NotificationHandler(o)
}</span>

func WithNotificationHandler(nh NotificationHandler) SessionOption <span class="cov0" title="0">{
        return notificationHandlerOpt(nh)
}</span>

// Session is represents a netconf session to a one given device.
type Session struct {
        tr        transport.Transport
        sessionID uint64
        seq       atomic.Uint64

        clientCaps          capabilitySet
        serverCaps          capabilitySet
        notificationHandler NotificationHandler

        mu      sync.Mutex
        reqs    map[uint64]*req
        closing bool
}

// NotificationHandler function allows to work with received notifications.
// A NotificationHandler function can be passed in as an option when calling Open method of Session object
// A typical use of the NofificationHandler function is to retrieve notifications once they are received so
// that they can be parsed and/or stored somewhere.
type NotificationHandler func(msg Notification)

func newSession(transport transport.Transport, opts ...SessionOption) *Session <span class="cov8" title="24">{
        cfg := sessionConfig{
                capabilities: DefaultCapabilities,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt.apply(&amp;cfg)
        }</span>

        <span class="cov8" title="24">s := &amp;Session{
                tr:                  transport,
                clientCaps:          newCapabilitySet(cfg.capabilities...),
                reqs:                make(map[uint64]*req),
                notificationHandler: cfg.notificationHandler,
        }
        return s</span>
}

// Open will create a new Session with th=e given transport and open it with the
// necessary hello messages.
func Open(transport transport.Transport, opts ...SessionOption) (*Session, error) <span class="cov0" title="0">{
        s := newSession(transport, opts...)

        // this needs a timeout of some sort.
        if err := s.handshake(); err != nil </span><span class="cov0" title="0">{
                s.tr.Close() // nolint:errcheck // TODO: catch and log err
                return nil, err
        }</span>

        <span class="cov0" title="0">go s.recv()
        return s, nil</span>
}

// handshake exchanges handshake messages and reports if there are any errors.
func (s *Session) handshake() error <span class="cov4" title="4">{
        clientMsg := helloMsg{
                Capabilities: s.clientCaps.All(),
        }
        if err := s.writeMsg(&amp;clientMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write hello message: %w", err)
        }</span>

        <span class="cov4" title="4">r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="4">defer r.Close() // nolint:errcheck // TODO: catch and log err

        var serverMsg helloMsg
        if err := xml.NewDecoder(r).Decode(&amp;serverMsg); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to read server hello message: %w", err)
        }</span>

        <span class="cov3" title="3">if serverMsg.SessionID == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("server did not return a session-id")
        }</span>

        <span class="cov2" title="2">if len(serverMsg.Capabilities) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("server did not return any capabilities")
        }</span>

        <span class="cov1" title="1">s.serverCaps = newCapabilitySet(serverMsg.Capabilities...)
        s.sessionID = serverMsg.SessionID

        // upgrade the transport if we are on a larger version and the transport
        // supports it.
        const baseCap11 = baseCap + ":1.1"
        if s.serverCaps.Has(baseCap11) &amp;&amp; s.clientCaps.Has(baseCap11) </span><span class="cov0" title="0">{
                if upgrader, ok := s.tr.(interface{ Upgrade() }); ok </span><span class="cov0" title="0">{
                        upgrader.Upgrade()
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// SessionID returns the current session ID exchanged in the hello messages.
// Will return 0 if there is no session ID.
func (s *Session) SessionID() uint64 <span class="cov0" title="0">{
        return s.sessionID
}</span>

// ClientCapabilities will return the capabilities initialized with the session.
func (s *Session) ClientCapabilities() []string <span class="cov0" title="0">{
        return s.clientCaps.All()
}</span>

// ServerCapabilities will return the capabilities returned by the server in
// it's hello message.
func (s *Session) ServerCapabilities() []string <span class="cov0" title="0">{
        return s.serverCaps.All()
}</span>

// startElement will walk though a xml.Decode until it finds a start element
// and returns it.
func startElement(d *xml.Decoder) (*xml.StartElement, error) <span class="cov8" title="24">{
        for </span><span class="cov8" title="24">{
                tok, err := d.Token()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="24">if start, ok := tok.(xml.StartElement); ok </span><span class="cov8" title="24">{
                        return &amp;start, nil
                }</span>
        }
}

type req struct {
        reply chan Reply
        ctx   context.Context
}

func (s *Session) recvMsg() error <span class="cov10" title="48">{
        r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="24">defer r.Close() // nolint:errcheck // TODO: catch error and log
        dec := xml.NewDecoder(r)

        root, err := startElement(dec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="24">const (
                ncNamespace    = "urn:ietf:params:xml:ns:netconf:base:1.0"
                notifNamespace = "urn:ietf:params:xml:ns:netconf:notification:1.0"
        )

        switch root.Name </span>{
        case xml.Name{Space: notifNamespace, Local: "notification"}:<span class="cov0" title="0">
                if s.notificationHandler == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">var notif Notification
                if err := dec.DecodeElement(&amp;notif, root); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decode notification message: %w", err)
                }</span>
                <span class="cov0" title="0">s.notificationHandler(notif)</span>
        case xml.Name{Space: ncNamespace, Local: "rpc-reply"}:<span class="cov8" title="24">
                var reply Reply
                if err := dec.DecodeElement(&amp;reply, root); err != nil </span><span class="cov0" title="0">{
                        // What should we do here?  Kill the connection?
                        return fmt.Errorf("failed to decode rpc-reply message: %w", err)
                }</span>
                <span class="cov8" title="24">ok, req := s.req(reply.MessageID)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot find reply channel for message-id: %d", reply.MessageID)
                }</span>

                <span class="cov8" title="24">select </span>{
                case req.reply &lt;- reply:<span class="cov8" title="24">
                        return nil</span>
                case &lt;-req.ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("message %d context canceled: %s", reply.MessageID, req.ctx.Err().Error())</span>
                }
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown message type: %q", root.Name.Local)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// recv is the main receive loop.  It runs concurrently to be able to handle
// interleaved messages (like notifications).
func (s *Session) recv() <span class="cov8" title="24">{
        var err error
        var opErr *net.OpError

        for </span><span class="cov10" title="48">{
                err = s.recvMsg()
                if errors.Is(err, io.EOF) || errors.Is(err, io.ErrUnexpectedEOF) || errors.As(err, &amp;opErr) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="24">if err != nil </span><span class="cov0" title="0">{
                        log.Printf("netconf: failed to read incoming message: %v", err)
                }</span>
        }
        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        // Close all outstanding requests
        for _, req := range s.reqs </span><span class="cov0" title="0">{
                close(req.reply)
        }</span>

        <span class="cov0" title="0">if !s.closing </span><span class="cov0" title="0">{
                log.Printf("netconf: connection closed unexpectedly")
        }</span>
}

func (s *Session) req(msgID uint64) (bool, *req) <span class="cov8" title="24">{
        s.mu.Lock()
        defer s.mu.Unlock()

        req, ok := s.reqs[msgID]
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="24">delete(s.reqs, msgID)
        return true, req</span>
}

func (s *Session) writeMsg(v any) error <span class="cov8" title="28">{
        w, err := s.tr.MsgWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="28">if err := xml.NewEncoder(w).Encode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="28">return w.Close()</span>
}

func (s *Session) send(ctx context.Context, msg *request) (chan Reply, error) <span class="cov8" title="24">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if err := s.writeMsg(msg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // cap of 1 makes sure we don't block on send
        <span class="cov8" title="24">ch := make(chan Reply, 1)
        s.reqs[msg.MessageID] = &amp;req{
                reply: ch,
                ctx:   ctx,
        }

        return ch, nil</span>
}

// Do issues a rpc call for the given NETCONF operation returning a Reply.  RPC
// errors (i.e erros in the `&lt;rpc-errors&gt;` section of the `&lt;rpc-reply&gt;`) are
// converted into go errors automatically.  Instead use `reply.Err()` or
// `reply.RPCErrors` to access the errors and/or warnings.
func (s *Session) Do(ctx context.Context, req any) (*Reply, error) <span class="cov8" title="24">{
        msg := &amp;request{
                MessageID: s.seq.Add(1),
                Operation: req,
        }

        ch, err := s.send(ctx, msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // wait for reply or context to be cancelled.
        <span class="cov8" title="24">select </span>{
        case reply, ok := &lt;-ch:<span class="cov8" title="24">
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrClosed
                }</span>
                <span class="cov8" title="24">return &amp;reply, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                // remove any existing request
                s.mu.Lock()
                delete(s.reqs, msg.MessageID)
                s.mu.Unlock()

                return nil, ctx.Err()</span>
        }
}

// Call issues a rpc message with `req` as the body and decodes the reponse into
// a pointer at `resp`.  Any Call errors are presented as a go error.
func (s *Session) Call(ctx context.Context, req any, resp any) error <span class="cov8" title="24">{
        reply, err := s.Do(ctx, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="24">if err := reply.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="24">if err := reply.Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="24">return nil</span>
}

// Close will gracefully close the sessions first by sending a `close-session`
// operation to the remote and then closing the underlying transport
func (s *Session) Close(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        s.closing = true
        s.mu.Unlock()

        type closeSession struct {
                XMLName xml.Name `xml:"close-session"`
        }

        // This may fail so save the error but still close the underlying transport.
        _, callErr := s.Do(ctx, &amp;closeSession{})

        // Close the connection and ignore errors if the remote side hung up first.
        if err := s.tr.Close(); err != nil &amp;&amp;
                !errors.Is(err, net.ErrClosed) &amp;&amp;
                !errors.Is(err, io.EOF) &amp;&amp;
                !errors.Is(err, syscall.EPIPE) </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if !errors.Is(callErr, io.EOF) </span><span class="cov0" title="0">{
                return callErr
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package transport

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "math"
        "os"
        "path/filepath"
        "time"
)

// ErrMalformedChunk represents a message that invalid as defined in the chunk
// framing in RFC6242
var ErrMalformedChunk = errors.New("netconf: invalid chunk")

type frameReader interface {
        io.ReadCloser
        io.ByteReader
}

type frameWriter interface {
        io.WriteCloser
        isClosed() bool
}

// Framer is a wrapper used for transports that implement the framing defined in
// RFC6242.  This supports End-of-Message and Chucked framing methods and
// will move from End-of-Message to Chunked framing after the `Upgrade` method
// has been called.
//
// This is not a transport on it's own (missing the `Close` method) and is
// intended to be embedded into other transports.
type Framer struct {
        r io.Reader
        w io.Writer

        br *bufio.Reader
        bw *bufio.Writer

        curReader frameReader
        curWriter frameWriter

        upgraded bool
}

// NewFramer return a new Framer to be used against the given io.Reader and io.Writer.
func NewFramer(r io.Reader, w io.Writer) *Framer <span class="cov0" title="0">{
        f := &amp;Framer{
                r:  r,
                w:  w,
                br: bufio.NewReader(r),
                bw: bufio.NewWriter(w),
        }

        capDir := os.Getenv("GONETCONF_FRAMED_CAPDIR")
        if capDir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(capDir, 0o755); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("GO_NETCONF_FRAMER: failed to create capture output dir: %v", err))</span>
                }

                <span class="cov0" title="0">ts := time.Now().Format(time.RFC3339)

                inFilename := filepath.Join(capDir, ts+".in")
                inf, err := os.Create(inFilename)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to create capture file %q: %v", inFilename, err))</span>
                }

                <span class="cov0" title="0">outFilename := filepath.Join(capDir, ts+".out")
                outf, err := os.Create(outFilename)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to create capture file %q: %v", inFilename, err))</span>
                }

                <span class="cov0" title="0">f.DebugCapture(inf, outf)</span>
        }

        <span class="cov0" title="0">return f</span>
}

// DebugCapture will copy all *framed* input/output to the the given
// `io.Writers` for sent or recv data.  Either sent of recv can be nil to not
// capture any data.  Useful for displaying to a screen or capturing to a file
// for debugging.
//
// This needs to be called before `MsgReader` or `MsgWriter`.
func (f *Framer) DebugCapture(in io.Writer, out io.Writer) <span class="cov0" title="0">{
        // XXX: should there be a sentinel flag to indicate write/read has been done already?
        if f.curReader != nil ||
                f.curWriter != nil ||
                f.bw.Buffered() &gt; 0 ||
                f.br.Buffered() &gt; 0 </span><span class="cov0" title="0">{
                panic("debug capture added with active reader or writer")</span>
        }

        <span class="cov0" title="0">if out != nil </span><span class="cov0" title="0">{
                f.w = io.MultiWriter(f.w, out)
                f.bw = bufio.NewWriter(f.w)
        }</span>

        <span class="cov0" title="0">if in != nil </span><span class="cov0" title="0">{
                f.r = io.TeeReader(f.r, in)
                f.br = bufio.NewReader(f.r)
        }</span>
}

// Upgrade will cause the Framer to switch from End-of-Message framing to
// Chunked framing.  This is usually called after netconf exchanged the hello
// messages.
func (t *Framer) Upgrade() <span class="cov0" title="0">{
        // XXX: do we need to protect against race conditions (atomic/mutex?)
        t.upgraded = true
}</span>

// MsgReader returns a new io.Reader that is good for reading exactly one netconf
// message.
//
// Only one reader can be used at a time.  When this is called with an existing
// reader then the underlying reader is advanced to the start of the next message
// and invalidates the old reader before returning a new one.
func (t *Framer) MsgReader() (io.ReadCloser, error) <span class="cov0" title="0">{
        if t.upgraded </span><span class="cov0" title="0">{
                t.curReader = &amp;chunkReader{r: t.br}
        }</span> else<span class="cov0" title="0"> {
                t.curReader = &amp;eomReader{r: t.br}
        }</span>
        <span class="cov0" title="0">return t.curReader, nil</span>
}

// MsgWriter returns an io.WriterCloser that is good for writing exactly one
// netconf message.
//
// One one writer can be used at one time and calling this function with an
// existing, unclosed,  writer will result in an error.
func (t *Framer) MsgWriter() (io.WriteCloser, error) <span class="cov0" title="0">{
        if t.curWriter != nil &amp;&amp; !t.curWriter.isClosed() </span><span class="cov0" title="0">{
                return nil, ErrExistingWriter
        }</span>

        <span class="cov0" title="0">if t.upgraded </span><span class="cov0" title="0">{
                t.curWriter = &amp;chunkWriter{w: t.bw}
        }</span> else<span class="cov0" title="0"> {
                t.curWriter = &amp;eomWriter{w: t.bw}
        }</span>
        <span class="cov0" title="0">return t.curWriter, nil</span>
}

var endOfChunks = []byte("\n##\n")

// Defined in https://www.rfc-editor.org/rfc/rfc6242#section-4.2
const maxChunk = math.MaxUint32

type chunkReader struct {
        r         *bufio.Reader
        chunkLeft uint32
}

func (r *chunkReader) readHeader() error <span class="cov6" title="52">{
        peeked, err := r.r.Peek(4)
        switch err </span>{
        case nil:<span class="cov5" title="30">
                break</span>
        case io.EOF:<span class="cov5" title="22">
                return io.ErrUnexpectedEOF</span>
        default:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov5" title="30">if _, err := r.r.Discard(2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // make sure the preamble of `\n#` which is used for both the start of a
        // chuck and the end-of-chunk marker is valid.
        <span class="cov5" title="30">if peeked[0] != '\n' || peeked[1] != '#' </span><span class="cov2" title="4">{
                return ErrMalformedChunk
        }</span>

        // check to see if we are at the end of the read
        <span class="cov5" title="26">if peeked[2] == '#' &amp;&amp; peeked[3] == '\n' </span><span class="cov3" title="8">{
                if _, err := r.r.Discard(2); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // not strictly needed but it is the responsibility of this function to
                // update chunkLeft.
                <span class="cov3" title="8">r.chunkLeft = 0
                return io.EOF</span>
        }

        <span class="cov5" title="18">var n uint32
        for </span><span class="cov6" title="56">{
                c, err := r.r.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov6" title="56">if c == '\n' </span><span class="cov4" title="16">{
                        break</span>
                }
                <span class="cov6" title="40">if c &lt; '0' || c &gt; '9' </span><span class="cov1" title="2">{
                        return ErrMalformedChunk
                }</span>
                <span class="cov6" title="38">n = n*10 + uint32(c) - '0'</span>
        }

        <span class="cov4" title="16">if n &lt; 1 || n &gt; maxChunk </span><span class="cov2" title="4">{
                return ErrMalformedChunk
        }</span>

        <span class="cov4" title="12">r.chunkLeft = n
        return nil</span>
}

func (r *chunkReader) Read(p []byte) (int, error) <span class="cov4" title="16">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>
        // make sure we can't try to read more than the max chunk
        <span class="cov4" title="16">if len(p) &gt; maxChunk </span><span class="cov0" title="0">{
                p = p[:maxChunk]
        }</span>

        // done with existing chunk so grab the next one
        <span class="cov4" title="16">if r.chunkLeft &lt;= 0 </span><span class="cov4" title="16">{
                if err := r.readHeader(); err != nil </span><span class="cov4" title="10">{
                        return 0, err
                }</span>
        }

        // XXX: This potential down conversion should be safe cause we resize p
        // above.  Hopefully no one is trying to read 4GB in one call.
        <span class="cov3" title="6">if uint32(len(p)) &gt; r.chunkLeft </span><span class="cov3" title="6">{
                p = p[:r.chunkLeft]
        }</span>

        <span class="cov3" title="6">n, err := r.r.Read(p)
        r.chunkLeft -= uint32(n)
        return n, err</span>
}

func (r *chunkReader) ReadByte() (byte, error) <span class="cov7" title="120">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        // done with existing chunck so grab the next one
        <span class="cov7" title="120">if r.chunkLeft &lt;= 0 </span><span class="cov4" title="16">{
                if err := r.readHeader(); err != nil </span><span class="cov4" title="10">{
                        return 0, err
                }</span>
        }

        <span class="cov7" title="110">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov7" title="110">r.chunkLeft--
        return b, nil</span>
}

// Close will read the rest of the frame and consume it including
// the end-of-frame markers if we haven't already done so.
func (r *chunkReader) Close() error <span class="cov5" title="20">{
        // poison the reader so that it can no longer be used
        defer func() </span><span class="cov5" title="20">{ r.r = nil }</span>()

        // read all remaining chunks until we get to the end of the frame.
        <span class="cov5" title="20">for </span><span class="cov5" title="20">{
                if r.chunkLeft &lt;= 0 </span><span class="cov5" title="20">{
                        // readHeader return io.EOF when it encounter the end-of-frame
                        // marker ("\n##\n")
                        err := r.readHeader()
                        switch </span>{
                        case err == nil:<span class="cov0" title="0">
                                break</span>
                        case errors.Is(err, io.EOF):<span class="cov0" title="0">
                                return nil</span>
                        default:<span class="cov5" title="20">
                                return err</span>
                        }
                }

                <span class="cov0" title="0">n, err := r.r.Discard(int(r.chunkLeft))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">r.chunkLeft -= uint32(n)</span>
        }
}

type chunkWriter struct {
        w *bufio.Writer
}

func (w *chunkWriter) Write(p []byte) (int, error) <span class="cov1" title="2">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov1" title="2">if _, err := fmt.Fprintf(w.w, "\n#%d\n", len(p)); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="2">return w.w.Write(p)</span>
}

func (w *chunkWriter) Close() error <span class="cov1" title="1">{
        // poison the writer to prevent writes after close
        defer func() </span><span class="cov1" title="1">{ w.w = nil }</span>()
        <span class="cov1" title="1">if _, err := w.w.Write(endOfChunks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return w.w.Flush()</span>
}

func (w *chunkWriter) isClosed() bool <span class="cov0" title="0">{ return w.w == nil }</span>

var endOfMsg = []byte("]]&gt;]]&gt;")

type eomReader struct {
        r *bufio.Reader
}

func (r *eomReader) Read(p []byte) (int, error) <span class="cov3" title="7">{
        // This probably isn't optimal however it looks like xml.Decoder
        // mainly just called ReadByte() and this probably won't ever be
        // used.
        for i := 0; i &lt; len(p); i++ </span><span class="cov8" title="310">{
                b, err := r.ReadByte()
                if err != nil </span><span class="cov3" title="7">{
                        return i, err
                }</span>
                <span class="cov8" title="303">p[i] = b</span>
        }
        <span class="cov0" title="0">return len(p), nil</span>
}

func (r *eomReader) ReadByte() (byte, error) <span class="cov10" title="640">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov10" title="640">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov4" title="12">{
                if err == io.EOF </span><span class="cov4" title="12">{
                        return b, io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return b, err</span>
        }

        // look for the end of the message marker
        <span class="cov9" title="628">if b == endOfMsg[0] </span><span class="cov5" title="24">{
                peeked, err := r.r.Peek(len(endOfMsg) - 1)
                if err != nil </span><span class="cov2" title="4">{
                        if err == io.EOF </span><span class="cov2" title="4">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">return 0, err</span>
                }

                // check if we are at the end of the message
                <span class="cov5" title="20">if bytes.Equal(peeked, endOfMsg[1:]) </span><span class="cov4" title="12">{
                        if _, err := r.r.Discard(len(endOfMsg) - 1); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>

                        <span class="cov4" title="12">return 0, io.EOF</span>
                }
        }

        <span class="cov9" title="612">return b, nil</span>
}

// Close will read the rest of the frame and consume it including
// the end-of-frame marker.
func (r *eomReader) Close() error <span class="cov4" title="14">{
        // poison the reader so that it can no longer be used
        defer func() </span><span class="cov4" title="14">{ r.r = nil }</span>()

        <span class="cov4" title="14">var err error
        for err == nil </span><span class="cov5" title="20">{
                _, err = r.ReadByte()
                if errors.Is(err, io.EOF) </span><span class="cov1" title="2">{
                        return nil
                }</span>
        }
        <span class="cov4" title="12">return err</span>
}

type eomWriter struct {
        w *bufio.Writer
}

func (w *eomWriter) Write(p []byte) (int, error) <span class="cov1" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>
        <span class="cov1" title="1">return w.w.Write(p)</span>
}

func (w *eomWriter) Close() error <span class="cov1" title="1">{
        // poison the writer to prevent writes after close
        defer func() </span><span class="cov1" title="1">{ w.w = nil }</span>()

        <span class="cov1" title="1">if err := w.w.WriteByte('\n'); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if _, err := w.w.Write(endOfMsg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return w.w.Flush()</span>
}

func (w *eomWriter) isClosed() bool <span class="cov0" title="0">{ return w.w == nil }</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package ssh

import (
        "context"
        "fmt"
        "io"
        "net"

        "golang.org/x/crypto/ssh"
        "nemith.io/netconf/transport"
)

// alias it to a private type so we can make it private when embedding
type framer = transport.Framer

// Transport implements RFC6242 for implementing NETCONF protocol over SSH.
type Transport struct {
        c     *ssh.Client
        sess  *ssh.Session
        stdin io.WriteCloser

        // set to true if the transport is managing the underlying ssh connection
        // and should close it when the transport is closed.  This is is set to true
        // when used with `Dial`.
        managed bool

        *framer
}

// Dial will connect to a ssh server and issues a transport, it's used as a
// convenience function as essentially is the same as
//
//                c, err := ssh.Dial(network, addr, config)
//                 if err != nil { /* ... handle error ... */ }
//                 t, err := NewTransport(c)
//
// When the transport is closed the underlying connection is also closed.
func Dial(ctx context.Context, network, addr string, config *ssh.ClientConfig) (*Transport, error) <span class="cov8" title="1">{
        d := net.Dialer{Timeout: config.Timeout}
        conn, err := d.DialContext(ctx, network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Setup a go routine to monitor the context and close the connection.  This
        // is needed as the underlying ssh library doesn't support contexts so this
        // approximates a context based cancelation/timeout for the ssh handshake.
        //
        // An alternative would be timeout based with conn.SetDeadline(), but then we
        // would manage two timeouts.  One for tcp connection and one for ssh
        // handshake and wouldn't support any other event based cancelation.
        <span class="cov8" title="1">done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // context is canceled so close the underlying connection.  Will
                        // will catch ctx.Err() later.
                        _ = conn.Close()</span> // nolint:errcheck // TODO: catch and log err
                case &lt;-done:<span class="cov8" title="1"></span>
                }
        }()

        <span class="cov8" title="1">sshConn, chans, reqs, err := ssh.NewClientConn(conn, addr, config)
        if err != nil </span><span class="cov0" title="0">{
                // if there is a context timeout return that error instead of the actual
                // error from ssh.NewClientConn.
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, ctx.Err()
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">close(done) // make sure we cleanup the context monitor routine

        client := ssh.NewClient(sshConn, chans, reqs)
        return newTransport(client, true)</span>
}

// NewTransport will create a new ssh transport as defined in RFC6242 for use
// with netconf.  Unlike Dial, the underlying client will not be automatically
// closed when the transport is closed (however any sessions and subsystems
// are still closed).
func NewTransport(client *ssh.Client) (*Transport, error) <span class="cov0" title="0">{
        return newTransport(client, false)
}</span>

func newTransport(client *ssh.Client, managed bool) (*Transport, error) <span class="cov8" title="1">{
        sess, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create ssh session: %w", err)
        }</span>

        <span class="cov8" title="1">w, err := sess.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov8" title="1">r, err := sess.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov8" title="1">const subsystem = "netconf"
        if err := sess.RequestSubsystem(subsystem); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start netconf ssh subsytem: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Transport{
                c:       client,
                managed: managed,
                sess:    sess,
                stdin:   w,

                framer: transport.NewFramer(r, w),
        }, nil</span>
}

// Close will close the underlying transport.  If the connection was created
// with Dial then then underlying ssh.Client is closed as well.  If not only
// the sessions is closed.
func (t *Transport) Close() error <span class="cov8" title="1">{
        // TODO: in go 1.20 this could easily be an errors.Join() but for now we
        // will save previous errors but try to close everything returning just the
        // "lowest" abstraction layer error
        var retErr error

        if err := t.stdin.Close(); err != nil </span><span class="cov0" title="0">{
                retErr = fmt.Errorf("failed to close ssh stdin: %w", err)
        }</span>

        <span class="cov8" title="1">if err := t.sess.Close(); err != nil </span><span class="cov0" title="0">{
                retErr = fmt.Errorf("failed to close ssh channel: %w", err)
        }</span>

        <span class="cov8" title="1">if t.managed </span><span class="cov8" title="1">{
                if err := t.c.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close ssh connnection: %w", t.c.Close())
                }</span>
        }

        <span class="cov8" title="1">return retErr</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package tls

import (
        "context"
        "crypto/tls"
        "net"

        "nemith.io/netconf/transport"
)

// alias it to a private type so we can make it private when embedding
type framer = transport.Framer

// Transport implements RFC7589 for implementing NETCONF over TLS.
type Transport struct {
        conn *tls.Conn
        *framer
}

// Dial will connect to a server via TLS and retuns a Transport.
func Dial(ctx context.Context, network, addr string, config *tls.Config) (*Transport, error) <span class="cov0" title="0">{
        var d net.Dialer
        conn, err := d.DialContext(ctx, network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tlsConn := tls.Client(conn, config)
        return NewTransport(tlsConn), nil</span>

}

// NewTransport takes an already connected tls transport and returns a new
// Transport.
func NewTransport(conn *tls.Conn) *Transport <span class="cov0" title="0">{
        return &amp;Transport{
                conn:   conn,
                framer: transport.NewFramer(conn, conn),
        }
}</span>

// Close will close the transport and the underlying TLS connection.
func (t *Transport) Close() error <span class="cov0" title="0">{
        return t.conn.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
