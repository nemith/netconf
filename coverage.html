
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>netconf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">nemith.io/netconf/capability.go (72.2%)</option>
				
				<option value="file1">nemith.io/netconf/msg.go (13.0%)</option>
				
				<option value="file2">nemith.io/netconf/rpc/config.go (80.0%)</option>
				
				<option value="file3">nemith.io/netconf/rpc/filter.go (100.0%)</option>
				
				<option value="file4">nemith.io/netconf/rpc/rpc.go (81.8%)</option>
				
				<option value="file5">nemith.io/netconf/rpc/session.go (0.0%)</option>
				
				<option value="file6">nemith.io/netconf/session.go (13.9%)</option>
				
				<option value="file7">nemith.io/netconf/transport/frame.go (64.2%)</option>
				
				<option value="file8">nemith.io/netconf/transport/ssh/ssh.go (82.2%)</option>
				
				<option value="file9">nemith.io/netconf/transport/tls/tls.go (90.9%)</option>
				
				<option value="file10">nemith.io/netconf/transport/transport.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package netconf

import (
        "iter"
)

const (
        baseCap      = "urn:ietf:params:netconf:base"
        stdCapPrefix = "urn:ietf:params:netconf:capability"

        CapNetConf10 = baseCap + ":1.0"
        CapNetConf11 = baseCap + ":1.1"
)

// DefaultCapabilities are the capabilities sent by the client during the hello
// exchange by the server.
var DefaultCapabilities = []string{
        CapNetConf10,
        CapNetConf11,
        // XXX: these seems like server capabilities and i don't see why
        // a client would need to send them
        // "urn:ietf:params:netconf:capability:writable-running:1.0",
        // "urn:ietf:params:netconf:capability:candidate:1.0",
        // "urn:ietf:params:netconf:capability:confirmed-commit:1.0",
        // "urn:ietf:params:netconf:capability:rollback-on-error:1.0",
        // "urn:ietf:params:netconf:capability:startup:1.0",
        // "urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp",
        // "urn:ietf:params:netconf:capability:validate:1.0",
        // "urn:ietf:params:netconf:capability:xpath:1.0",
        // "urn:ietf:params:netconf:capability:notification:1.0",
        // "urn:ietf:params:netconf:capability:interleave:1.0",
        // "urn:ietf:params:netconf:capability:with-defaults:1.0",
}

// ExpandCapability will automatically add the standard capability prefix of
// `urn:ietf:params:netconf:capability` if not already present.
func ExpandCapability(s string) string <span class="cov10" title="4">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov10" title="4">if s[0] != ':' </span><span class="cov10" title="4">{
                return s
        }</span>

        <span class="cov0" title="0">return stdCapPrefix + s</span>
}

type CapabilitySet struct {
        caps map[string]struct{}
}

// NewCapabilitySet creates a new CapabilitySet and adds any provided
// capabilities.
func NewCapabilitySet(capabilities ...string) CapabilitySet <span class="cov1" title="1">{
        cs := CapabilitySet{
                caps: make(map[string]struct{}),
        }
        for _, cap := range capabilities </span><span class="cov5" title="2">{
                cap = ExpandCapability(cap)
                cs.caps[cap] = struct{}{}
        }</span>
        <span class="cov1" title="1">return cs</span>
}

// Len returns the number of capabilities in the set.
func (cs CapabilitySet) Len() int <span class="cov0" title="0">{
        return len(cs.caps)
}</span>

// All returns an iterator over all capabilities in the set.  If you want a
// slice use `slices.Collect(cs.All())`.
func (cs CapabilitySet) All() iter.Seq[string] <span class="cov10" title="4">{
        return func(yield func(string) bool) </span><span class="cov10" title="4">{
                for cap := range cs.caps </span><span class="cov0" title="0">{
                        if !yield(cap) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Has will return true if the capability is present in the set.  The given
// capability is expanded with `ExpandCapability` if needed.
func (cs CapabilitySet) Has(s string) bool <span class="cov5" title="2">{
        s = ExpandCapability(s)
        _, ok := cs.caps[s]
        return ok
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package netconf

import (
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "slices"
        "strings"
        "time"
)

// RPC maps the xml value of &lt;rpc&gt; in RFC6241
type RPC struct {
        XMLName xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc"`

        // Managed by the session.  Will be overwritten when sent on the wire.
        MessageID string `xml:"message-id,attr"`

        // User-defined attributes (e.g. xmlns:ex="...").  Per RFC6241 sec 7.3, these
        // must be preserved and reflected in the associated &lt;rpc-reply&gt;.
        Attributes []xml.Attr `xml:",attr"`

        // The inner XML of the RPC message (e.g. &lt;get-config&gt;, &lt;edit-config&gt;)
        Operation any `xml:",innerxml"` // The operation payload (e.g. &lt;get-config&gt;)
}

type RPCReply struct {
        XMLName xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc-reply"`

        // The message-id must match that of the associated &lt;rpc&gt;
        MessageID string `xml:"message-id,attr"`

        // Additional attributes on the &lt;rpc-reply&gt;.
        Attributes []xml.Attr `xml:",attr"`

        RPCErrors RPCErrors `xml:"rpc-error,omitempty"`
}

type ErrSeverity string

const (
        SevError   ErrSeverity = "error"
        SevWarning ErrSeverity = "warning"
)

type ErrType string

const (
        ErrTypeTransport ErrType = "transport"
        ErrTypeRPC       ErrType = "rpc"
        ErrTypeProtocol  ErrType = "protocol"
        ErrTypeApp       ErrType = "app"
)

type ErrTag string

const (
        ErrInUse                 ErrTag = "in-use"
        ErrInvalidValue          ErrTag = "invalid-value"
        ErrTooBig                ErrTag = "too-big"
        ErrMissingAttribute      ErrTag = "missing-attribute"
        ErrBadAttribute          ErrTag = "bad-attribute"
        ErrUnknownAttribute      ErrTag = "unknown-attribute"
        ErrMissingElement        ErrTag = "missing-element"
        ErrBadElement            ErrTag = "bad-element"
        ErrUnknownElement        ErrTag = "unknown-element"
        ErrUnknownNamespace      ErrTag = "unknown-namespace"
        ErrAccesDenied           ErrTag = "access-denied"
        ErrLockDenied            ErrTag = "lock-denied"
        ErrResourceDenied        ErrTag = "resource-denied"
        ErrRollbackFailed        ErrTag = "rollback-failed"
        ErrDataExists            ErrTag = "data-exists"
        ErrDataMissing           ErrTag = "data-missing"
        ErrOperationNotSupported ErrTag = "operation-not-supported"
        ErrOperationFailed       ErrTag = "operation-failed"
        ErrPartialOperation      ErrTag = "partial-operation"
        ErrMalformedMessage      ErrTag = "malformed-message"
)

type RPCError struct {
        Type     ErrType     `xml:"error-type"`
        Tag      ErrTag      `xml:"error-tag"`
        Severity ErrSeverity `xml:"error-severity"`
        AppTag   string      `xml:"error-app-tag,omitempty"`
        Path     string      `xml:"error-path,omitempty"`
        Message  string      `xml:"error-message,omitempty"`
        Info     RawXML      `xml:"error-info,omitempty"`
}

func (e RPCError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("netconf error: %s %s: %s", e.Type, e.Tag, e.Message)
}</span>

type RPCErrors []RPCError

func (errs RPCErrors) Filter(severity ...ErrSeverity) RPCErrors <span class="cov0" title="0">{
        if len(errs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if len(severity) == 0 </span><span class="cov0" title="0">{
                severity = []ErrSeverity{SevError}
        }</span>

        <span class="cov0" title="0">filteredErrs := make(RPCErrors, 0, len(errs))
        for _, err := range errs </span><span class="cov0" title="0">{
                if !slices.Contains(severity, err.Severity) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filteredErrs = append(filteredErrs, err)</span>
        }
        <span class="cov0" title="0">return filteredErrs</span>
}

func (errs RPCErrors) Error() string <span class="cov0" title="0">{
        if len(errs) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if len(errs) == 1 </span><span class="cov0" title="0">{
                return errs[0].Error()
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("multiple netconf errors:\n")
        for i, err := range errs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteRune('\n')
                }</span>
                <span class="cov0" title="0">sb.WriteString(err.Error())</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

func (errs RPCErrors) Unwrap() error <span class="cov0" title="0">{
        if len(errs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(errs) == 1 </span><span class="cov0" title="0">{
                return errs[0]
        }</span>

        <span class="cov0" title="0">unboxedErrs := make([]error, len(errs))
        for i, err := range errs </span><span class="cov0" title="0">{
                unboxedErrs[i] = err
        }</span>
        <span class="cov0" title="0">return errors.Join(unboxedErrs...)</span>
}

type Notification struct {
        XMLName   xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:notification:1.0 notification"`
        EventTime time.Time `xml:"eventTime"`
}

// HelloMsg maps the xml value of the &lt;hello&gt; message in RFC6241
type HelloMsg struct {
        XMLName      xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 hello"`
        SessionID    uint64   `xml:"session-id,omitempty"`
        Capabilities []string `xml:"capabilities&gt;capability"`
}

type Request struct {
        RPC RPC
}

func NewRequest(op any) *Request <span class="cov0" title="0">{
        return &amp;Request{
                RPC: RPC{
                        Operation: op,
                },
        }
}</span>

type Response struct {
        io.ReadCloser

        MessageID  string     // Captured from the message-id attribute
        Attributes []xml.Attr // Any other attributes on the envelope
}

// Decode will decode the response XML into the provided value v and then close
// the message releasing the session to process new messages.
func (d *Response) Decode(v any) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                err = errors.Join(err, d.Close())
        }</span>()

        <span class="cov0" title="0">if err := xml.NewDecoder(d).Decode(v); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (d *Response) Close() error <span class="cov0" title="0">{
        if d.ReadCloser == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return d.ReadCloser.Close()</span>
}

// RawXML is a helper type for getting innerxml content as a byte slice.
type RawXML []byte

func (x *RawXML) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov10" title="4">{
        var inner struct {
                Data []byte `xml:",innerxml"`
        }

        if err := d.DecodeElement(&amp;inner, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="4">*x = inner.Data
        return nil</span>
}

func (x RawXML) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov10" title="4">{
        inner := struct {
                Data []byte `xml:",innerxml"`
        }{
                Data: []byte(x),
        }
        return e.EncodeElement(&amp;inner, start)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package rpc

import (
        "context"
        "encoding/xml"
        "fmt"

        "nemith.io/netconf"
)

// Datastore represents a NETCONF configuration datastore as defined in
// RFC6241 section 7.1
type Datastore string

func (d Datastore) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov6" title="27">{
        if d == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("datastore name cannot be empty")
        }</span>

        <span class="cov6" title="26">for i := range len(d) </span><span class="cov10" title="216">{
                c := d[i]
                if (c &lt; 'a' || c &gt; 'z') &amp;&amp;
                        (c &lt; 'A' || c &gt; 'Z') &amp;&amp;
                        (c &lt; '0' || c &gt; '9') &amp;&amp;
                        c != '_' &amp;&amp; c != '-' &amp;&amp; c != '.' </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid datastore name: %q", d)
                }</span>
        }

        <span class="cov6" title="25">inner := struct {
                Elem string `xml:",innerxml"`
        }{Elem: "&lt;" + string(d) + "/&gt;"}

        // EncodeElement(nil, ...) creates a self-closing tag &lt;running/&gt;
        return e.EncodeElement(&amp;inner, start)</span>
}

const (
        // Running configuration datastore. Required by RFC6241
        Running Datastore = "running"

        // Candidate configuration configuration datastore.  Supported with the
        // `:candidate` capability defined in RFC6241 section 8.3
        Candidate Datastore = "candidate"

        // Startup configuration configuration datastore.  Supported with the
        // `:startup` capability defined in RFC6241 section 8.7
        Startup Datastore = "startup"
)

type URL string

func (u URL) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov2" title="2">{
        v := struct {
                URL string `xml:"url"`
        }{string(u)}
        return e.EncodeElement(&amp;v, start)
}</span>

// GetConfig implements the &lt;get-config&gt; rpc operation defined in [RFC6241 7.1].
// `source` is the datastore to query.
//
// [RFC6241 7.1]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.1
type GetConfig struct {
        Source Datastore
        Filter Filter
}

func (op GetConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov3" title="4">{
        req := struct {
                XMLName xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 get-config"`
                Source  Datastore `xml:"source"`
                Filter  Filter    `xml:"filter,omitempty"`
        }{
                Source: op.Source,
                Filter: op.Filter,
        }

        return e.Encode(&amp;req)
}</span>

func (rpc GetConfig) Exec(ctx context.Context, session *netconf.Session) ([]byte, error) <span class="cov1" title="1">{
        var reply GetConfigReply
        if err := session.Exec(ctx, rpc, &amp;reply); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return reply.Config, nil</span>
}

type GetConfigReply struct {
        Config []byte
}

func (r *GetConfigReply) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov1" title="1">{
        type dataWrapper struct {
                Data struct {
                        Inner []byte `xml:",innerxml"`
                } `xml:"data"`
        }

        var wrapper dataWrapper
        if err := d.DecodeElement(&amp;wrapper, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">r.Config = wrapper.Data.Inner
        return nil</span>
}

// DefaultOperation defines the strategies for merging configuration in a
// `&lt;edit-config&gt; operation`.
type DefaultOperation string

const (
        // MergeConfig configuration elements are merged together at the level at
        // which this specified.  Can be used for config elements as well as default.
        MergeConfig DefaultOperation = "merge"

        // ReplaceConfig defines that the incoming config change should replace the
        // existing config at the level which it is specified.  This can be
        // specified on individual config elements or set as the default strategy.
        ReplaceConfig DefaultOperation = "replace"

        // NoneOperation indicates that no default operation should be applied and
        // nothing is applied to the target configuration unless there are
        // operations defined on the configs subelements.
        NoneOperation DefaultOperation = "none"
)

// TestOption defines the behavior for testing configuration before applying it
// in a `&lt;edit-config&gt;` operation.
type TestOption string

const (
        // TestThenSet will validate the configuration and only if is is valid then
        // apply the configuration to the datastore.
        TestThenSet TestOption = "test-then-set"

        // SetOnly will not do any testing before applying it.
        SetOnly TestOption = "set"

        // Test only will validatate the incoming configuration and return the
        // results without modifying the underlying store.
        TestOnly TestOption = "test-only"
)

// ErrorOption defines the behavior when an error is encountered during a
// `&lt;edit-config&gt;` operation.
type ErrorOption string

const (
        // StopOnError will abort the `&lt;edit-config&gt;` operation on the first error.
        StopOnError ErrorOption = "stop-on-error"

        // ContinueOnError will continue to parse the configuration data even if an
        // error is encountered.  Errors are still recorded and reported in the
        // reply.
        ContinueOnError ErrorOption = "continue-on-error"

        // RollbackOnError will restore the configuration back to before the
        // `&lt;edit-config&gt;` operation took place.  This requires the device to
        // support the `:rollback-on-error` capability.
        RollbackOnError ErrorOption = "rollback-on-error"
)

// EditConfig issues the `&lt;edit-config&gt;` operation defined in [RFC6241 7.2] for
// updating an existing target config datastore.
//
// [RFC6241 7.2]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.2
type EditConfig struct {
        Target           Datastore
        DefaultOperation DefaultOperation
        TestOption       TestOption
        ErrorOption      ErrorOption
        Config           any
}

func (rpc EditConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov3" title="5">{
        req := struct {
                XMLName          xml.Name         `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 edit-config"`
                Target           Datastore        `xml:"target"`
                DefaultOperation DefaultOperation `xml:"default-operation,omitempty"`
                TestOption       TestOption       `xml:"test-option,omitempty"`
                ErrorOption      ErrorOption      `xml:"error-option,omitempty"`

                Config any    `xml:"config,omitempty"`
                URL    string `xml:"url,omitempty"`
        }{
                Target:           rpc.Target,
                DefaultOperation: rpc.DefaultOperation,
                TestOption:       rpc.TestOption,
                ErrorOption:      rpc.ErrorOption,
        }

        switch v := rpc.Config.(type) </span>{
        case URL:<span class="cov1" title="1">
                req.URL = string(v)</span>
        case string:<span class="cov2" title="3">
                req.Config = struct {
                        Inner string `xml:",innerxml"`
                }{Inner: v}</span>
        case []byte:<span class="cov1" title="1">
                req.Config = struct {
                        Inner []byte `xml:",innerxml"`
                }{Inner: v}</span>
        default:<span class="cov0" title="0">
                req.Config = rpc.Config</span>
        }

        <span class="cov3" title="5">return e.Encode(&amp;req)</span>
}

func (rpc EditConfig) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("edit-config: operation failed, &lt;ok&gt; not received")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// CopyConfig issues the `&lt;copy-config&gt;` operation as defined in [RFC6241 7.3]
// for copying an entire config to/from a source and target datastore.
//
// A `&lt;config&gt;` element defining a full config can be used as the source.
//
// If a device supports the `:url` capability than a [URL] object can be used
// for the source or target datastore.
//
// [RFC6241 7.3] https://www.rfc-editor.org/rfc/rfc6241.html#section-7.3
type CopyConfig struct {
        Source any
        Target any
}

func (rpc CopyConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov2" title="3">{
        req := struct {
                XMLName xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 copy-config"`
                Source  any      `xml:"source"`
                Target  any      `xml:"target"`
        }{
                Source: rpc.Source,
                Target: rpc.Target,
        }

        return e.Encode(&amp;req)
}</span>

func (rpc CopyConfig) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("copy-config: operation failed, &lt;ok&gt; not received")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DeleteConfigReq represents the `&lt;delete-config&gt;` operation defined in
// [RFC6241 7.4] for deleting a configuration datastore.
//
// [RFC6241 7.4]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.4
type DeleteConfig struct {
        Target Datastore
}

func (rpc DeleteConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov2" title="2">{
        req := struct {
                XMLName xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 delete-config"`
                Target  any      `xml:"target"`
        }{
                Target: rpc.Target,
        }

        return e.Encode(&amp;req)
}</span>

func (rpc DeleteConfig) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("delete-config: operation failed, &lt;ok&gt; not received")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// LockReq represents the `&lt;lock&gt;` operation defined in [RFC6241 7.5] for
// locking a configuration datastore.
//
// [RFC6241 7.5]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.5
type Lock struct {
        Target Datastore
}

func (rpc Lock) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov2" title="2">{
        req := struct {
                XMLName xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 lock"`
                Target  Datastore `xml:"target"`
        }{
                Target: rpc.Target,
        }

        return e.Encode(&amp;req)
}</span>

func (rpc Lock) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("lock: operation failed, &lt;ok&gt; not received")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type Unlock struct {
        Target Datastore
}

func (rpc Unlock) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov2" title="2">{
        req := struct {
                XMLName xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 unlock"`
                Target  Datastore `xml:"target"`
        }{
                Target: rpc.Target,
        }

        return e.Encode(&amp;req)
}</span>

func (rpc Unlock) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("unlock: operation failed, &lt;ok&gt; not received")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

type Validate struct {
        Source any
}

func (rpc Validate) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov2" title="2">{
        req := struct {
                XMLName xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 validate"`
                Source  any      `xml:"source"`
        }{
                Source: rpc.Source,
        }

        return e.Encode(&amp;req)
}</span>

func (rpc Validate) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: operation failed, &lt;ok&gt; not received")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Commit represents the `&lt;commit&gt;` operation defined in [RFC6241 8.5] for
// committing candidate configuration to the running datastore.
//
// [RFC6241 8.5]: https://www.rfc-editor.org/rfc/rfc6241.html#section-8.5
type Commit struct {
        // Confirmed indicates that the commit must be confirmed with a follow-up
        // commit within the confirm-timeout period (default 600 seconds).  If not
        // confirmed, the commit will be reverted.
        //
        // Device must support :confirmed-commit:1.1 capability.
        Confirmed bool

        // ConfirmTimeout is the time in seconds to wait before reverting a
        // confirmed commit.
        //
        // Device must support :confirmed-commit:1.1 capability.
        ConfirmTimeout int64

        // Persist indicates that the confirmed commit can be persisted across
        // sessions and confirmed in a different session.
        //
        // If Confirmed is set this expands to the &lt;persist&gt; element.
        //
        // If Confirmed is not set this expands to the &lt;persist-id&gt; element to
        // confirm a previous commit with the same id.
        PersistID string
}

func (rpc Commit) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov3" title="5">{
        req := struct {
                XMLName        xml.Name   `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 commit"`
                Confirmed      ExtantBool `xml:"confirmed,omitempty"`
                ConfirmTimeout int64      `xml:"confirm-timeout,omitempty"`
                Persist        string     `xml:"persist,omitempty"`
                PersistID      string     `xml:"persist-id,omitempty"`
        }{
                Confirmed:      ExtantBool(rpc.Confirmed),
                ConfirmTimeout: rpc.ConfirmTimeout,
        }

        if rpc.PersistID != "" </span><span class="cov2" title="2">{
                if rpc.Confirmed </span><span class="cov1" title="1">{
                        req.Persist = rpc.PersistID
                }</span> else<span class="cov1" title="1"> {
                        req.PersistID = rpc.PersistID
                }</span>
        }

        <span class="cov3" title="5">return e.Encode(&amp;req)</span>
}

func (rpc Commit) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("commit: operation failed, &lt;ok&gt; not received")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

type CancelCommit struct {
        PersistID string
}

func (rpc CancelCommit) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov2" title="3">{
        req := struct {
                XMLName   xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 cancel-commit"`
                PersistID string   `xml:"persist-id,omitempty"`
        }{
                PersistID: rpc.PersistID,
        }
        return e.Encode(&amp;req)
}</span>

func (rpc CancelCommit) Exec(ctx context.Context, session *netconf.Session) error <span class="cov1" title="1">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("cancel-commit: operation failed, &lt;ok&gt; not received")
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package rpc

import (
        "encoding/xml"
        "maps"
        "slices"
)

type Filter interface {
        xml.Marshaler
        filter()
}

type subtreeFilter struct {
        f any
}

func (f subtreeFilter) filter() {<span class="cov0" title="0">}</span>

func (f subtreeFilter) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov10" title="5">{
        start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: "type"}, Value: "subtree"})

        switch v := f.f.(type) </span>{
        case string:<span class="cov7" title="3">
                inner := struct {
                        Data string `xml:",innerxml"`
                }{Data: v}
                return e.EncodeElement(&amp;inner, start)</span>
        case []byte:<span class="cov1" title="1">
                inner := struct {
                        Data []byte `xml:",innerxml"`
                }{Data: v}
                return e.EncodeElement(&amp;inner, start)</span>
        default:<span class="cov1" title="1">
                return e.EncodeElement(f.f, start)</span>

        }
}

// SubtreeFilter creates a filter matching the provided XML structure(s).
// Multiple arguments are merged into a single filter element as siblings.
func SubtreeFilter(filter any) Filter <span class="cov10" title="5">{
        return subtreeFilter{f: filter}
}</span>

type xpathFilter struct {
        Select     string
        Namespaces map[string]string
}

func (f xpathFilter) filter() {<span class="cov0" title="0">}</span>

func (f xpathFilter) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov7" title="3">{
        start.Attr = append(start.Attr,
                xml.Attr{Name: xml.Name{Local: "type"}, Value: "xpath"},
                xml.Attr{Name: xml.Name{Local: "select"}, Value: f.Select},
        )

        for _, prefix := range slices.Sorted(maps.Keys(f.Namespaces)) </span><span class="cov1" title="1">{
                uri := f.Namespaces[prefix]
                attrName := "xmlns:" + prefix
                start.Attr = append(start.Attr, xml.Attr{Name: xml.Name{Local: attrName}, Value: uri})
        }</span>

        <span class="cov7" title="3">return e.EncodeElement(struct{}{}, start)</span>
}

// XPathFilter creates a filter using XPath 1.0 expression.
// namespaces map prefixes used in the path to their URIs.
func XPathFilter(path string, namespaces map[string]string) Filter <span class="cov7" title="3">{
        return xpathFilter{Select: path, Namespaces: namespaces}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package rpc

import (
        "context"
        "encoding/xml"

        "nemith.io/netconf"
)

type ExtantBool bool

func (b ExtantBool) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov5" title="3">{
        if !b </span><span class="cov0" title="0">{
                return nil
        }</span>
        // This produces a empty start/end tag (i.e &lt;tag&gt;&lt;/tag&gt;) vs a self-closing
        // tag (&lt;tag/&gt;) which should be the same in XML, however I know certain
        // vendors may have issues with this format. We may have to process this
        // after xml encoding.
        //
        // See https://github.com/golang/go/issues/21399
        // or https://github.com/golang/go/issues/26756 for a different hack.
        <span class="cov5" title="3">return e.EncodeElement(struct{}{}, start)</span>
}

func (b *ExtantBool) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov10" title="10">{
        *b = true
        return d.Skip()
}</span>

type OkReply struct {
        netconf.RPCReply
        OK ExtantBool `xml:"ok"`
}

type Get struct {
        Filter Filter `xml:"filter,omitempty"`
}

func (rpc *Get) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov5" title="3">{
        req := struct {
                XMLName xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 get"`
                Filter  Filter   `xml:"filter,omitempty"`
        }{
                Filter: rpc.Filter,
        }
        return e.Encode(&amp;req)
}</span>

type GetReply struct {
        netconf.RPCReply
        Data struct {
                XML []byte `xml:",innerxml"`
        } `xml:"data"`
}

func (rpc *Get) Exec(ctx context.Context, session *netconf.Session) ([]byte, error) <span class="cov1" title="1">{
        var resp GetReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data.XML, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package rpc

import (
        "context"
        "encoding/xml"
        "fmt"

        "nemith.io/netconf"
)

// KillSessionReq represents the `&lt;kill-session&gt;` operation defined in
// [RFC6241 7.6] for terminating a NETCONF session.
//
// [RFC6241 7.6]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.6
type KillSession struct {
        SessionID uint
}

func (rpc *KillSession) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov0" title="0">{
        req := struct {
                XMLName   xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 kill-session"`
                SessionID uint     `xml:"session-id"`
        }{
                SessionID: rpc.SessionID,
        }
        return e.EncodeElement(&amp;req, start)
}</span>

func (rpc *KillSession) Exec(ctx context.Context, session *netconf.Session) error <span class="cov0" title="0">{
        var resp OkReply
        if err := session.Exec(ctx, rpc, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !resp.OK </span><span class="cov0" title="0">{
                return fmt.Errorf("kill-session: operation failed, &lt;ok&gt; not received")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package netconf

import (
        "bytes"
        "context"
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "log"
        "net"
        "slices"
        "strconv"
        "sync"
        "sync/atomic"
        "syscall"

        "nemith.io/netconf/transport"
)

const (
        NetconfNamespace      = "urn:ietf:params:xml:ns:netconf:base:1.0"
        NotificationNamespace = "urn:ietf:params:xml:ns:netconf:notification:1.0"
)

var ErrClosed = errors.New("closed connection")

type sessionConfig struct {
        clientCaps []string
}

type SessionOption interface {
        apply(*sessionConfig)
}

type capabilityOpt []string

func (o capabilityOpt) apply(cfg *sessionConfig) <span class="cov0" title="0">{
        cfg.clientCaps = []string(o)
}</span>

func WithCapability(capabilities ...string) SessionOption <span class="cov0" title="0">{
        return capabilityOpt(capabilities)
}</span>

// Session is represents a netconf session to a one given device.
type Session struct {
        tr        transport.Transport
        sessionID uint64
        seq       atomic.Uint64

        clientCaps CapabilitySet
        serverCaps CapabilitySet

        mu      sync.Mutex
        reqs    map[string]*pendingReq
        closing bool
}

func newSession(transport transport.Transport, opts ...SessionOption) *Session <span class="cov0" title="0">{
        cfg := sessionConfig{
                clientCaps: DefaultCapabilities,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt.apply(&amp;cfg)
        }</span>

        <span class="cov0" title="0">s := &amp;Session{
                tr:         transport,
                clientCaps: NewCapabilitySet(cfg.clientCaps...),
                reqs:       make(map[string]*pendingReq),
        }
        return s</span>
}

// Open will create a new Session with th=e given transport and open it with the
// necessary hello messages.
func Open(transport transport.Transport, opts ...SessionOption) (*Session, error) <span class="cov0" title="0">{
        s := newSession(transport, opts...)

        // this needs a timeout of some sort.
        if err := s.handshake(); err != nil </span><span class="cov0" title="0">{
                s.tr.Close() // nolint:errcheck // TODO: catch and log err
                return nil, err
        }</span>

        <span class="cov0" title="0">go s.recvLoop()
        return s, nil</span>
}

// handshake exchanges handshake messages and reports if there are any errors.
func (s *Session) handshake() error <span class="cov10" title="4">{
        clientMsg := HelloMsg{
                Capabilities: slices.Collect(s.clientCaps.All()),
        }

        w, err := s.tr.MsgWriter()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get hello message writer: %w", err)
        }</span>
        <span class="cov10" title="4">defer func() </span><span class="cov10" title="4">{
                // TODO: expose this error
                _ = w.Close()
        }</span>()

        <span class="cov10" title="4">if err := xml.NewEncoder(w).Encode(&amp;clientMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write hello message: %w", err)
        }</span>
        <span class="cov10" title="4">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close hello message writer: %w", err)
        }</span>

        <span class="cov10" title="4">r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get hello message reader: %w", err)
        }</span>
        <span class="cov10" title="4">defer func() </span><span class="cov10" title="4">{
                // TODO: expose this error
                _ = r.Close()
        }</span>()

        <span class="cov10" title="4">var serverMsg HelloMsg
        if err := xml.NewDecoder(r).Decode(&amp;serverMsg); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to read server hello message: %w", err)
        }</span>

        <span class="cov8" title="3">if serverMsg.SessionID == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("server did not return a session-id")
        }</span>

        <span class="cov5" title="2">if len(serverMsg.Capabilities) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("server did not return any capabilities")
        }</span>

        <span class="cov1" title="1">s.serverCaps = NewCapabilitySet(serverMsg.Capabilities...)
        s.sessionID = serverMsg.SessionID

        // upgrade the transport if we are on a larger version and the transport
        // supports it.
        if s.serverCaps.Has(CapNetConf11) &amp;&amp; s.clientCaps.Has(CapNetConf11) </span><span class="cov0" title="0">{
                if upgrader, ok := s.tr.(interface{ Upgrade() }); ok </span><span class="cov0" title="0">{
                        upgrader.Upgrade()
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// SessionID returns the current session ID exchanged in the hello messages.
// Will return 0 if there is no session ID.
func (s *Session) SessionID() uint64 <span class="cov0" title="0">{
        return s.sessionID
}</span>

// ClientCaps will return the capabilities initialized with the session.
func (s *Session) ClientCaps() *CapabilitySet <span class="cov0" title="0">{
        return &amp;s.clientCaps
}</span>

// ServerCaps will return the capabilities returned by the server in
// it's hello message.
func (s *Session) ServerCaps() *CapabilitySet <span class="cov0" title="0">{
        return &amp;s.serverCaps
}</span>

// startElement will walk though a xml.Decode until it finds a start element
// and returns it.
func startElement(d *xml.Decoder) (*xml.StartElement, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                tok, err := d.Token()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if start, ok := tok.(xml.StartElement); ok </span><span class="cov0" title="0">{
                        return &amp;start, nil
                }</span>
        }
}

type pendingReq struct {
        reply chan *Response
        ctx   context.Context
}

type replyReader struct {
        io.Reader
        closer io.Closer

        done chan struct{}
        once sync.Once
}

func (r *replyReader) Close() error <span class="cov0" title="0">{
        var err error
        r.once.Do(func() </span><span class="cov0" title="0">{
                err = r.closer.Close()
                close(r.done)
        }</span>)
        <span class="cov0" title="0">return err</span>
}

// recvLoop is the main receive loop.  It runs concurrently to be able to handle
// interleaved messages (like notifications).
func (s *Session) recvLoop() <span class="cov0" title="0">{
        // buffer used to "peel" into the message enough to read the first element
        // (i.e &lt;rpc-reply&gt; or &lt;notification&gt;)
        buf := make([]byte, 4096)
        for </span><span class="cov0" title="0">{
                if err := s.recvMsg(buf); err != nil </span><span class="cov0" title="0">{
                        log.Printf("netconf: failed to receive message: %v", err)
                        break</span>
                }
        }

        // Final cleanup when the loop exits
        <span class="cov0" title="0">s.mu.Lock()
        for _, req := range s.reqs </span><span class="cov0" title="0">{
                close(req.reply)
        }</span>
        <span class="cov0" title="0">s.mu.Unlock()
        // TODO: expose this error
        _ = s.tr.Close()

        if !s.closing </span><span class="cov0" title="0">{
                log.Printf("netconf: connection closed unexpectedly")
        }</span>
}

func getMessageID(attrs []xml.Attr) string <span class="cov0" title="0">{
        for _, attr := range attrs </span><span class="cov0" title="0">{
                if attr.Name.Local == "message-id" </span><span class="cov0" title="0">{
                        return attr.Value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (s *Session) recvMsg(buf []byte) error <span class="cov0" title="0">{
        r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // TODO: expose this error
                _ = r.Close()
        }</span>()

        // 3. Peek/Read the start of the message
        <span class="cov0" title="0">n, err := r.Read(buf)
        if err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                // It is okay to return EOF here; recv() handles the check.
                return err
        }</span>

        <span class="cov0" title="0">chunk := buf[:n]
        decoder := xml.NewDecoder(bytes.NewReader(chunk))

        startElem, err := startElement(decoder)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse message start: %w", err)
        }</span>

        <span class="cov0" title="0">msgReader := io.MultiReader(bytes.NewReader(chunk), r)

        switch startElem.Name </span>{
        case xml.Name{Space: NetconfNamespace, Local: "rpc-reply"}:<span class="cov0" title="0">
                msgID := getMessageID(startElem.Attr)
                if msgID == "" </span><span class="cov0" title="0">{
                        log.Printf("netconf: rpc-reply missing message-id")
                        return nil // Continue loop
                }</span>

                <span class="cov0" title="0">s.mu.Lock()
                req, ok := s.reqs[msgID]
                delete(s.reqs, msgID)
                s.mu.Unlock()

                if !ok </span><span class="cov0" title="0">{
                        log.Printf("netconf: unexpected rpc-reply with message-id %s (possible timeout?)", msgID)
                        return nil // Continue loop
                }</span>

                <span class="cov0" title="0">readDone := make(chan struct{})
                reader := &amp;replyReader{
                        Reader: msgReader,
                        closer: r, // The raw transport reader
                        done:   readDone,
                }

                select </span>{
                case req.reply &lt;- &amp;Response{
                        ReadCloser: reader,
                        MessageID:  msgID,
                        Attributes: startElem.Attr,
                }:<span class="cov0" title="0">
                        // We wait for the user to call Close() on the replyReader.
                        &lt;-readDone
                        return nil</span>

                case &lt;-req.ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                }

        default:<span class="cov0" title="0">
                return fmt.Errorf("netconf: unknown message type: %s", startElem.Name.Local)</span>
        }
}

// Do issues a rpc message for the given Request.  This is a low-level method
// that doesn't try to decode the response including any rpc-errors.
func (s *Session) Do(ctx context.Context, req *Request) (*Response, error) <span class="cov0" title="0">{
        msgID := strconv.FormatUint(s.seq.Add(1), 10)
        req.RPC.MessageID = msgID

        // Setup channel
        ch := make(chan *Response, 1)
        s.mu.Lock()
        s.reqs[msgID] = &amp;pendingReq{
                reply: ch,
                ctx:   ctx,
        }
        s.mu.Unlock()

        // Cleanup if context triggers before send/recv
        defer func() </span><span class="cov0" title="0">{
                s.mu.Lock()
                delete(s.reqs, msgID)
                s.mu.Unlock()
        }</span>()

        <span class="cov0" title="0">w, err := s.tr.MsgWriter()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get message writer: %w", err)
        }</span>
        <span class="cov0" title="0">if err := xml.NewEncoder(w).Encode(req.RPC); err != nil </span><span class="cov0" title="0">{
                _ = w.Close() // try to close anyway
                return nil, fmt.Errorf("failed to encode request: %w", err)
        }</span>
        <span class="cov0" title="0">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to flush request: %w", err)
        }</span>

        // Wait for the response
        <span class="cov0" title="0">select </span>{
        case resp, ok := &lt;-ch:<span class="cov0" title="0">
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrClosed
                }</span>
                <span class="cov0" title="0">return resp, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }
}

// Exec issues a rpc message with `req` as the body and decodes the response into
// a pointer at `resp`.  Resp must include the full &lt;rpc-reply&gt; structure.
func (s *Session) Exec(ctx context.Context, operation any, reply any) error <span class="cov0" title="0">{
        req := Request{RPC: RPC{Operation: operation}}

        resp, err := s.Do(ctx, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = resp.Close()
        }</span>()

        <span class="cov0" title="0">raw, err := io.ReadAll(resp)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read reply: %w", err)
        }</span>

        <span class="cov0" title="0">var rpcReply RPCReply
        if err := xml.Unmarshal(raw, &amp;rpcReply); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse rpc-reply: %w", err)
        }</span>
        // filter out warnings
        <span class="cov0" title="0">rpcErrors := rpcReply.RPCErrors.Filter(SevError)
        if len(rpcErrors) &gt; 0 </span><span class="cov0" title="0">{
                return rpcErrors
        }</span>

        <span class="cov0" title="0">if reply != nil </span><span class="cov0" title="0">{
                if err := xml.Unmarshal(raw, reply); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decode response: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Close will gracefully close the sessions first by sending a `close-session`
// operation to the remote and then closing the underlying transport
func (s *Session) Close(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        s.closing = true
        s.mu.Unlock()

        type closeSession struct {
                XMLName xml.Name `xml:"close-session"`
        }

        // This may fail so save the error but still close the underlying transport.
        req := NewRequest(&amp;closeSession{})
        resp, _ := s.Do(ctx, req)
        if resp != nil </span><span class="cov0" title="0">{
                _ = resp.Close()
        }</span>

        // Close the connection and ignore errors if the remote side hung up first.
        <span class="cov0" title="0">if err := s.tr.Close(); err != nil &amp;&amp;
                !errors.Is(err, net.ErrClosed) &amp;&amp;
                !errors.Is(err, io.EOF) &amp;&amp;
                !errors.Is(err, syscall.EPIPE) </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package transport

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "math"
        "sync"
)

var ErrStreamBusy = errors.New("transport: stream is already active")

// Framer is a wrapper used for transports that implement the framing defined in
// RFC6242.  This supports End-of-Message and Chunked framing methods and
// will move from End-of-Message to Chunked framing after the `Upgrade` method
// has been called.
//
// This is not a transport on it's own (missing the `Close` method) and is
// intended to be embedded into other transports.
type Framer struct {
        r io.Reader
        w io.Writer

        br *bufio.Reader
        bw *bufio.Writer

        mu           sync.Mutex
        chunkFraming bool
        activeReader bool
        activeWriter bool
}

// NewFramer return a new Framer to be used against the given io.Reader and io.Writer.
func NewFramer(r io.Reader, w io.Writer) *Framer <span class="cov0" title="0">{
        return &amp;Framer{
                r:  r,
                w:  w,
                br: bufio.NewReader(r),
                bw: bufio.NewWriter(w),
        }
}</span>

// DebugCapture will copy all *framed* input/output to the the given
// `io.Writers` for sent or recv data.  Either sent of recv can be nil to not
// capture any data.  Useful for displaying to a screen or capturing to a file
// for debugging.
//
// This needs to be called before `MsgReader` or `MsgWriter`.
func (f *Framer) DebugCapture(input, output io.Writer) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()

        if f.activeReader ||
                f.activeWriter ||
                f.bw.Buffered() &gt; 0 ||
                f.br.Buffered() &gt; 0 </span><span class="cov0" title="0">{
                panic("debug capture added with active reader or writer")</span>
        }

        <span class="cov0" title="0">if input != nil </span><span class="cov0" title="0">{
                f.br = bufio.NewReader(io.TeeReader(f.r, input))
        }</span>

        <span class="cov0" title="0">if output != nil </span><span class="cov0" title="0">{
                f.bw = bufio.NewWriter(io.MultiWriter(f.w, output))
        }</span>
}

// Upgrade will cause the Framer to switch from End-of-Message framing to
// Chunked framing.  This is usually called after netconf exchanged the hello
// messages.
func (f *Framer) Upgrade() <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.chunkFraming = true
}</span>

func (f *Framer) closeReader() <span class="cov5" title="34">{
        if f == nil </span><span class="cov5" title="34">{
                return
        }</span>
        <span class="cov0" title="0">f.mu.Lock()
        defer f.mu.Unlock()
        f.activeReader = false</span>
}

func (f *Framer) closeWriter() <span class="cov1" title="2">{
        if f == nil </span><span class="cov1" title="2">{
                return
        }</span>
        <span class="cov0" title="0">f.mu.Lock()
        defer f.mu.Unlock()
        f.activeWriter = false</span>
}

func (f *Framer) MsgReader() (io.ReadCloser, error) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()

        if f.activeReader </span><span class="cov0" title="0">{
                return nil, ErrStreamBusy
        }</span>
        <span class="cov0" title="0">f.activeReader = true

        if f.chunkFraming </span><span class="cov0" title="0">{
                return &amp;chunkedReader{
                        r: f.br,
                        f: f,
                }, nil
        }</span>
        <span class="cov0" title="0">return &amp;markedReader{
                r: f.br,
                f: f,
        }, nil</span>
}

func (f *Framer) MsgWriter() (io.WriteCloser, error) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()

        if f.activeWriter </span><span class="cov0" title="0">{
                return nil, ErrStreamBusy
        }</span>
        <span class="cov0" title="0">f.activeWriter = true

        if f.chunkFraming </span><span class="cov0" title="0">{
                return &amp;chunkedWriter{
                        w: f.bw,
                        f: f,
                }, nil
        }</span>
        <span class="cov0" title="0">return &amp;markedWriter{
                w: f.bw,
                f: f,
        }, nil</span>
}

var endOfChunks = []byte("\n##\n")

// ErrMalformedChunk represents a message that invalid as defined in the chunk
// framing in RFC6242
var ErrMalformedChunk = errors.New("netconf: invalid chunk")

type chunkedReader struct {
        f         *Framer
        r         *bufio.Reader
        chunkLeft uint32
        eof       bool
}

func (r *chunkedReader) readHeader() (uint32, error) <span class="cov6" title="59">{
        // Peek at marker to check for "\n#"
        marker, err := r.r.Peek(4)
        if err != nil </span><span class="cov4" title="12">{
                if errors.Is(err, io.EOF) </span><span class="cov4" title="12">{
                        return 0, io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov6" title="47">if marker[0] != '\n' || marker[1] != '#' </span><span class="cov4" title="10">{
                return 0, ErrMalformedChunk
        }</span>

        <span class="cov6" title="37">if marker[2] == '#' &amp;&amp; marker[3] == '\n' </span><span class="cov4" title="9">{
                // Discard the end-of-chunks marker
                if _, err := r.r.Discard(4); err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>

                <span class="cov4" title="9">return 0, nil</span> // Signal end of message with 0 chunk size
        }

        // Discard the "\n#" preamble
        <span class="cov5" title="28">if _, err := r.r.Discard(2); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov5" title="28">line, err := r.r.ReadSlice('\n')
        if err != nil </span><span class="cov1" title="1">{
                if err == io.EOF </span><span class="cov1" title="1">{
                        return 0, io.ErrUnexpectedEOF
                }</span>
                // ReadSlice returns err if '\n' is missing (EOF or buffer full)
                <span class="cov0" title="0">return 0, err</span>
        }

        // Cut off the '\n' from the end for parsing
        <span class="cov5" title="27">digits := line[:len(line)-1]

        // If the line was just "\n", digits is empty (chunks must have size)
        if len(digits) == 0 </span><span class="cov0" title="0">{
                return 0, ErrMalformedChunk
        }</span>

        <span class="cov5" title="27">var chunkSize uint32
        for _, c := range digits </span><span class="cov7" title="82">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov2" title="4">{
                        return 0, ErrMalformedChunk
                }</span>

                <span class="cov7" title="78">if chunkSize &gt; math.MaxUint32/10 </span><span class="cov1" title="1">{
                        return 0, ErrMalformedChunk
                }</span>
                <span class="cov7" title="77">chunkSize = chunkSize * 10

                digit := uint32(c - '0')
                if chunkSize &gt; math.MaxUint32-digit </span><span class="cov2" title="3">{
                        return 0, ErrMalformedChunk
                }</span>
                <span class="cov7" title="74">chunkSize += digit</span>
        }

        <span class="cov5" title="19">if chunkSize == 0 </span><span class="cov2" title="4">{
                return 0, ErrMalformedChunk
        }</span>

        <span class="cov4" title="15">return chunkSize, nil</span>
}

func (r *chunkedReader) Read(p []byte) (int, error) <span class="cov4" title="16">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov4" title="16">if len(p) &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                p = p[:math.MaxUint32]
        }</span>

        // If we have no bytes left in the current chunk, we must read a new header
        <span class="cov4" title="16">if r.chunkLeft &lt;= 0 </span><span class="cov4" title="16">{
                chunkSize, err := r.readHeader()
                if err != nil </span><span class="cov3" title="6">{
                        return 0, err
                }</span>

                // Zero chunk size indicates "End of Chunks" (\n##\n)
                <span class="cov4" title="10">if chunkSize == 0 </span><span class="cov2" title="4">{
                        r.eof = true
                        return 0, io.EOF
                }</span>
                <span class="cov3" title="6">r.chunkLeft = chunkSize</span>
        }

        <span class="cov3" title="6">toRead := min(uint32(len(p)), r.chunkLeft)
        n, err := r.r.Read(p[:toRead])
        r.chunkLeft -= uint32(n)

        return n, err</span>
}

func (r *chunkedReader) ReadByte() (byte, error) <span class="cov7" title="120">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        // done with existing chunk so grab the next one
        <span class="cov7" title="120">if r.chunkLeft &lt;= 0 </span><span class="cov4" title="16">{
                n, err := r.readHeader()
                if err != nil </span><span class="cov3" title="6">{
                        return 0, err
                }</span>
                <span class="cov4" title="10">if n == 0 </span><span class="cov2" title="4">{
                        r.eof = true
                        return 0, io.EOF
                }</span>
                <span class="cov3" title="6">r.chunkLeft = n</span>
        }

        <span class="cov7" title="110">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov7" title="110">r.chunkLeft--
        return b, nil</span>
}

func (r *chunkedReader) Close() error <span class="cov5" title="20">{
        if r.r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov5" title="20">defer func() </span><span class="cov5" title="20">{
                r.r = nil
                r.f.closeReader()
        }</span>()

        // If we have already read to the end, nothing to do
        <span class="cov5" title="20">if r.eof </span><span class="cov3" title="8">{
                return nil
        }</span>

        // Drain the rest of the chunks until we hit the end-of-chunks marker
        <span class="cov4" title="12">for </span><span class="cov4" title="12">{
                if r.chunkLeft &lt;= 0 </span><span class="cov4" title="12">{
                        // readHeader return 0, nil when it hits the end-of-chunks
                        n, err := r.readHeader()
                        if err != nil </span><span class="cov4" title="12">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">r.chunkLeft = n</span>
                }

                <span class="cov0" title="0">for r.chunkLeft &gt; 0 </span><span class="cov0" title="0">{
                        // Protect against int overflow on 32-bit systems
                        toDiscard := int(r.chunkLeft)
                        if uint(r.chunkLeft) &gt; uint(math.MaxInt) </span><span class="cov0" title="0">{
                                toDiscard = math.MaxInt
                        }</span>

                        <span class="cov0" title="0">n, err := r.r.Discard(toDiscard)
                        r.chunkLeft -= uint32(n)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
}

type chunkedWriter struct {
        f *Framer
        w *bufio.Writer
}

func (w *chunkedWriter) Write(p []byte) (int, error) <span class="cov1" title="2">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov1" title="2">totalWritten := 0
        for len(p) &gt; 0 </span><span class="cov1" title="2">{
                // Cap chunk size at MaxInt32 (~2GB) to avoid overflow issues on all
                // architectures.
                //
                // XXX: Should we default to smaller chunk sizes.  Default
                // buffer in a bufio writer is 4k and seems resonable?  Check what other
                // chunked implementations do?
                chunkSize := len(p)
                if chunkSize &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        chunkSize = math.MaxInt32
                }</span>

                // Write chunk header
                <span class="cov1" title="2">if _, err := fmt.Fprintf(w.w, "\n#%d\n", chunkSize); err != nil </span><span class="cov0" title="0">{
                        return totalWritten, err
                }</span>

                // Note: we are not checking for a partial writes as bufio.Writer
                // will only return a short write if the underlying writer returns an
                // error.
                <span class="cov1" title="2">n, err := w.w.Write(p[:chunkSize])
                totalWritten += n
                if err != nil </span><span class="cov0" title="0">{
                        return totalWritten, err
                }</span>

                // Advance
                <span class="cov1" title="2">p = p[n:]</span>
        }

        <span class="cov1" title="2">return totalWritten, nil</span>
}

func (w *chunkedWriter) Close() error <span class="cov1" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                w.w = nil
                w.f.closeWriter()
        }</span>()

        // write the end-of-chunks marker
        <span class="cov1" title="1">if _, err := w.w.Write(endOfChunks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return w.w.Flush()</span>
}

var endOfMsg = []byte("]]&gt;]]&gt;")

type markedReader struct {
        f   *Framer
        r   *bufio.Reader
        eof bool
}

func (r *markedReader) Read(p []byte) (int, error) <span class="cov3" title="7">{
        for i := 0; i &lt; len(p); i++ </span><span class="cov9" title="310">{
                b, err := r.ReadByte()
                if err != nil </span><span class="cov3" title="7">{
                        return i, err
                }</span>
                <span class="cov8" title="303">p[i] = b</span>
        }
        <span class="cov0" title="0">return len(p), nil</span>
}

func (r *markedReader) ReadByte() (byte, error) <span class="cov10" title="624">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov10" title="624">if r.eof </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>

        <span class="cov10" title="624">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov2" title="4">{
                if err == io.EOF </span><span class="cov2" title="4">{
                        return b, io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return b, err</span>
        }

        // look for the end of the message marker
        <span class="cov9" title="620">if b == endOfMsg[0] </span><span class="cov5" title="22">{
                peeked, err := r.r.Peek(len(endOfMsg) - 1)
                if err != nil </span><span class="cov2" title="4">{
                        if err == io.EOF </span><span class="cov2" title="4">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">return 0, err</span>
                }

                // check if we are at the end of the message
                <span class="cov5" title="18">if bytes.Equal(peeked, endOfMsg[1:]) </span><span class="cov4" title="10">{
                        if _, err := r.r.Discard(len(endOfMsg) - 1); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>

                        <span class="cov4" title="10">r.eof = true
                        return 0, io.EOF</span>
                }
        }

        <span class="cov9" title="606">return b, nil</span>
}

func (r *markedReader) Close() error <span class="cov4" title="14">{
        if r.r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov4" title="14">defer func() </span><span class="cov4" title="14">{
                r.r = nil
                r.f.closeReader()
        }</span>()

        // If we have already read to the end, nothing to do
        <span class="cov4" title="14">if r.eof </span><span class="cov4" title="10">{
                return nil
        }</span>

        <span class="cov2" title="4">var err error
        for err == nil </span><span class="cov2" title="4">{
                _, err = r.ReadByte()
                if errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov2" title="4">return err</span>
}

type markedWriter struct {
        f *Framer
        w *bufio.Writer
}

func (w *markedWriter) Write(p []byte) (int, error) <span class="cov1" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov1" title="1">return w.w.Write(p)</span>
}

func (w *markedWriter) Close() error <span class="cov1" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov1" title="1">defer func() </span><span class="cov1" title="1">{
                w.w = nil
                w.f.closeWriter()
        }</span>()

        <span class="cov1" title="1">if _, err := w.w.Write(endOfMsg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return w.w.Flush()</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package ssh

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net"

        "golang.org/x/crypto/ssh"
        "nemith.io/netconf/transport"
)

// alias it to a private type so we can make it private when embedding
type framer = transport.Framer

// Transport implements RFC6242 for implementing NETCONF protocol over SSH.
type Transport struct {
        c     *ssh.Client
        sess  *ssh.Session
        stdin io.WriteCloser

        // set to true if the transport is managing the underlying ssh connection
        // and should close it when the transport is closed.  This is is set to true
        // when used with `Dial`.
        managedConn bool

        *framer
}

// Dial will connect to a ssh server and issues a transport, it's used as a
// convenience function as essentially is the same as
//
//                c, err := ssh.Dial(network, addr, config)
//                 if err != nil { /* ... handle error ... */ }
//                 t, err := NewTransport(c)
//
// When the transport is closed the underlying connection is also closed.
func Dial(ctx context.Context, network, addr string, config *ssh.ClientConfig) (*Transport, error) <span class="cov10" title="6">{
        d := net.Dialer{Timeout: config.Timeout}
        conn, err := d.DialContext(ctx, network, addr)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Setup a go routine to monitor the context and close the connection.  This
        // is needed as the ssh library doesn't support contexts for dialing so this
        // approximates a context based cancelation/timeout for the ssh handshake.
        //
        // Since writing this code, Go 1.20 added DialContext to ssh.ClientConn but it doesn't support a custom configuration
        <span class="cov9" title="5">done := make(chan struct{})
        defer close(done)
        go func() </span><span class="cov9" title="5">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        _ = conn.Close()</span>
                case &lt;-done:<span class="cov7" title="4"></span>
                }
        }()

        <span class="cov9" title="5">sshConn, chans, reqs, err := ssh.NewClientConn(conn, addr, config)
        if err != nil </span><span class="cov4" title="2">{
                // ssh.NewClientConn closes the underlying connection so no need to call conn.Close()
                if ctx.Err() != nil </span><span class="cov1" title="1">{
                        return nil, ctx.Err()
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov6" title="3">client := ssh.NewClient(sshConn, chans, reqs)

        t, err := newTransport(client, true)
        if err != nil </span><span class="cov1" title="1">{
                // Close the client to not leak it on transport failure.
                _ = client.Close()
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, ctx.Err()
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }

        <span class="cov4" title="2">return t, nil</span>
}

// NewTransport will create a new ssh transport as defined in RFC6242 for use
// with netconf.  Unlike Dial, the underlying client will not be automatically
// closed when the transport is closed (however any sessions and subsystems
// are still closed).
func NewTransport(client *ssh.Client) (*Transport, error) <span class="cov0" title="0">{
        return newTransport(client, false)
}</span>

func newTransport(client *ssh.Client, managed bool) (*Transport, error) <span class="cov6" title="3">{
        sess, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create ssh session: %w", err)
        }</span>

        <span class="cov6" title="3">w, err := sess.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov6" title="3">r, err := sess.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov6" title="3">const subsystem = "netconf"
        if err := sess.RequestSubsystem(subsystem); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to start netconf ssh subsytem: %w", err)
        }</span>

        <span class="cov4" title="2">return &amp;Transport{
                c:           client,
                managedConn: managed,
                sess:        sess,
                stdin:       w,

                framer: transport.NewFramer(r, w),
        }, nil</span>
}

// Close will close the underlying transport.  If the connection was created
// with Dial then then underlying ssh.Client is closed as well.  If not only
// the sessions is closed.
func (t *Transport) Close() error <span class="cov4" title="2">{
        // will save previous errors but try to close everything returning just the
        // "lowest" abstraction layer error
        var retErr error

        if err := t.stdin.Close(); err != nil </span><span class="cov0" title="0">{
                retErr = errors.Join(retErr, fmt.Errorf("failed to close ssh stdin: %w", err))
        }</span>

        <span class="cov4" title="2">if err := t.sess.Close(); err != nil </span><span class="cov0" title="0">{
                retErr = errors.Join(retErr, fmt.Errorf("failed to close ssh channel: %w", err))
        }</span>

        // If this is a "managed connection" (i.e one created with Dial) then we are
        // responsible to close the connection.
        <span class="cov4" title="2">if t.managedConn </span><span class="cov4" title="2">{
                if err := t.c.Close(); err != nil </span><span class="cov0" title="0">{
                        return errors.Join(retErr, fmt.Errorf("failed to close ssh connection: %w", err))
                }</span>
        }

        <span class="cov4" title="2">return retErr</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tls

import (
        "context"
        "crypto/tls"
        "net"

        "nemith.io/netconf/transport"
)

// alias it to a private type so we can make it private when embedding
type framer = transport.Framer

// Transport implements RFC7589 for implementing NETCONF over TLS.
type Transport struct {
        conn *tls.Conn
        *framer
}

// Dial will connect to a NETCONF tls port and creates a new Transport.  It's
// used as a convenience function and essentially is the same as:
//
//        c, err := tls.Dial(network, addr, config)
//        if err != nil { /* ... handle error ... */ }
//        t, err := NewTransport(c)
//
// When the transport is closed the underlying connection is also closed.
func Dial(ctx context.Context, network, addr string, config *tls.Config) (*Transport, error) <span class="cov10" title="3">{
        var d net.Dialer
        conn, err := d.DialContext(ctx, network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">tlsConn := tls.Client(conn, config)

        if err := tlsConn.HandshakeContext(ctx); err != nil </span><span class="cov1" title="1">{
                _ = tlsConn.Close()
                return nil, err
        }</span>

        <span class="cov6" title="2">return NewTransport(tlsConn), nil</span>
}

// NewTransport takes an already connected tls transport and returns a new
// Transport.
func NewTransport(conn *tls.Conn) *Transport <span class="cov6" title="2">{
        return &amp;Transport{
                conn:   conn,
                framer: transport.NewFramer(conn, conn),
        }
}</span>

// Close will close the transport and the underlying TLS connection.
func (t *Transport) Close() error <span class="cov6" title="2">{
        return t.conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package transport

import (
        "bytes"
        "errors"
        "io"
)

var (
        // ErrInvalidIO is returned when a write or read operation is called on
        // message io.Reader or a message io.Writer when they are no longer valid.
        // (i.e a new reader or writer has been obtained)
        ErrInvalidIO = errors.New("netconf: read/write on invalid io")
)

// Transport is used for a netconf.Session to talk to the device. It is message
// oriented to allow for framing and other details to happen on a per message
// basis.
type Transport interface {
        // MsgReader returns a reader for the next message.
        // The caller must close the reader when done.
        MsgReader() (io.ReadCloser, error)

        // MsgWriter returns a writer for a new message. Closing it will finalize
        // the message framing and flush to the underlying transport.
        MsgWriter() (io.WriteCloser, error)

        Close() error
}

// TestTransport mocks the underlying NETCONF transport layer.
// It allows us to queue up "Server Responses" and inspect "Client Requests".
type TestTransport struct {
        // inputs is a queue of messages the Server "sends" to the Client.
        // The Session calls ReadMsg() to pop from this queue.
        inputs [][]byte

        // outputs captures messages the Client "sends" to the Server.
        // The Session calls WriteMsg() to append to this list.
        outputs [][]byte
}

type readNoopCloser struct{ io.Reader }

func (r readNoopCloser) Close() error <span class="cov0" title="0">{ return nil }</span>

type testWriter struct {
        tt  *TestTransport
        buf *bytes.Buffer
}

func (w *testWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        return w.buf.Write(p)
}</span>

func (w *testWriter) Close() error <span class="cov0" title="0">{
        w.tt.outputs = append(w.tt.outputs, w.buf.Bytes())
        return nil
}</span>

func (t *TestTransport) MsgReader() (io.ReadCloser, error) <span class="cov0" title="0">{
        if len(t.inputs) == 0 </span><span class="cov0" title="0">{
                return nil, io.EOF
        }</span>

        <span class="cov0" title="0">msg := t.inputs[0]
        t.inputs = t.inputs[1:]
        return readNoopCloser{bytes.NewReader(msg)}, nil</span>
}

func (t *TestTransport) MsgWriter() (io.WriteCloser, error) <span class="cov0" title="0">{
        return &amp;testWriter{tt: t, buf: &amp;bytes.Buffer{}}, nil
}</span>

func (t *TestTransport) Close() error <span class="cov0" title="0">{ return nil }</span>

// Helper to push a server response into the read queue
func (t *TestTransport) AddResponse(body string) <span class="cov0" title="0">{
        t.inputs = append(t.inputs, []byte(body))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
