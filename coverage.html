
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>netconf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nemith/netconf/capability.go (83.3%)</option>
				
				<option value="file1">github.com/nemith/netconf/msg.go (47.8%)</option>
				
				<option value="file2">github.com/nemith/netconf/ops.go (91.7%)</option>
				
				<option value="file3">github.com/nemith/netconf/session.go (56.9%)</option>
				
				<option value="file4">github.com/nemith/netconf/transport/frame.go (50.0%)</option>
				
				<option value="file5">github.com/nemith/netconf/transport/ssh/ssh.go (68.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package netconf

const (
        baseCap      = "urn:ietf:params:netconf:base"
        stdCapPrefix = "urn:ietf:params:netconf:capability"
)

// DefaultCapabilities are the capabilities sent by the client during the hello
// exchange by the server.
var DefaultCapabilities = []string{
        "urn:ietf:params:netconf:base:1.0",
        "urn:ietf:params:netconf:base:1.1",

        // XXX: these seems like server capabilities and i don't see why
        // a client would need to send them

        // "urn:ietf:params:netconf:capability:writable-running:1.0",
        // "urn:ietf:params:netconf:capability:candidate:1.0",
        // "urn:ietf:params:netconf:capability:confirmed-commit:1.0",
        // "urn:ietf:params:netconf:capability:rollback-on-error:1.0",
        // "urn:ietf:params:netconf:capability:startup:1.0",
        // "urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp",
        // "urn:ietf:params:netconf:capability:validate:1.0",
        // "urn:ietf:params:netconf:capability:xpath:1.0",
        // "urn:ietf:params:netconf:capability:notification:1.0",
        // "urn:ietf:params:netconf:capability:interleave:1.0",
        // "urn:ietf:params:netconf:capability:with-defaults:1.0",
}

// ExpandCapability will automatically add the standard capability prefix of
// `urn:ietf:params:netconf:capability` if not already present.
func ExpandCapability(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if s[0] != ':' </span><span class="cov8" title="1">{
                return s
        }</span>

        <span class="cov0" title="0">return stdCapPrefix + s</span>
}

// XXX: may want to expose this type publicly in the future when the api has
// stabilized?
type capabilitySet struct {
        caps map[string]struct{}
}

func newCapabilitySet(capabilities ...string) capabilitySet <span class="cov8" title="1">{
        cs := capabilitySet{
                caps: make(map[string]struct{}),
        }
        cs.Add(capabilities...)
        return cs
}</span>

func (cs *capabilitySet) Add(capabilities ...string) <span class="cov8" title="1">{
        for _, cap := range capabilities </span><span class="cov8" title="1">{
                cap = ExpandCapability(cap)
                cs.caps[cap] = struct{}{}
        }</span>
}

func (cs capabilitySet) Has(s string) bool <span class="cov8" title="1">{
        // XXX: need to figure out how to handle versions (i.e always map to 1.0 or
        // map to latest/any?)
        s = ExpandCapability(s)
        _, ok := cs.caps[s]
        return ok
}</span>

func (cs capabilitySet) All() []string <span class="cov8" title="1">{
        out := make([]string, 0, len(cs.caps))
        for cap := range cs.caps </span><span class="cov0" title="0">{
                out = append(out, cap)
        }</span>
        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package netconf

import (
        "encoding/xml"
        "fmt"
        "strings"
        "time"
)

// RawXML captures the raw xml for the given element.  Used to process certain
// elements later.
type RawXML []byte

func (x *RawXML) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        var inner struct {
                Data []byte `xml:",innerxml"`
        }

        if err := d.DecodeElement(&amp;inner, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*x = inner.Data
        return nil</span>
}

// MarshalXML implements xml.Marshaller.  Raw XML is passed verbatim, errors and
// all.
func (x *RawXML) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        inner := struct {
                Data []byte `xml:",innerxml"`
        }{
                Data: []byte(*x),
        }
        return e.EncodeElement(&amp;inner, start)
}</span>

// helloMsg maps the xml value of the &lt;hello&gt; message in RFC6241
type HelloMsg struct {
        XMLName      xml.Name `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 hello"`
        SessionID    uint64   `xml:"session-id,omitempty"`
        Capabilities []string `xml:"capabilities&gt;capability"`
}

// RPCMsg maps the xml value of &lt;rpc&gt; in RFC6241
type RPCMsg struct {
        XMLName   xml.Name    `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc"`
        MessageID uint64      `xml:"message-id,attr"`
        Operation interface{} `xml:",innerxml"`
}

func (msg *RPCMsg) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        if msg.Operation == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("operation cannot be nil")
        }</span>

        // TODO: validate operation is named?

        // alias the type to not cause recursion calling e.Encode
        <span class="cov8" title="1">type rpcMsg RPCMsg
        inner := rpcMsg(*msg)
        return e.Encode(&amp;inner)</span>
}

// RPCReplyMsg maps the xml value of &lt;rpc-reply&gt; in RFC6241
type RPCReplyMsg struct {
        XMLName   xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:base:1.0 rpc-reply"`
        MessageID uint64    `xml:"message-id,attr"`
        Errors    RPCErrors `xml:"rpc-error,omitempty"`
        Body      []byte    `xml:",innerxml"`
}

type NotificationMsg struct {
        XMLName   xml.Name  `xml:"urn:ietf:params:xml:ns:netconf:notification:1.0 notification"`
        EventTime time.Time `xml:"eventTime"`
        Data      []byte    `xml:",innerxml"`
}

type ErrSeverity string

const (
        ErrSevError   ErrSeverity = "error"
        ErrSevWarning ErrSeverity = "warning"
)

type ErrType string

const (
        ErrTypeTransport ErrType = "transport"
        ErrTypeRPC       ErrType = "rpc"
        ErrTypeProtocol  ErrType = "protocol"
        ErrTypeApp       ErrType = "app"
)

type ErrTag string

const (
        ErrInUse                 ErrTag = "in-use"
        ErrInvalidValue          ErrTag = "invalid-value"
        ErrTooBig                ErrTag = "too-big"
        ErrMissingAttribute      ErrTag = "missing-attribute"
        ErrBadAttribute          ErrTag = "bad-attribute"
        ErrUnknownAttribute      ErrTag = "unknown-attribute"
        ErrMissingElement        ErrTag = "missing-element"
        ErrBadElement            ErrTag = "bad-element"
        ErrUnknownElement        ErrTag = "unknown-element"
        ErrUnknownNamespace      ErrTag = "unknown-namespace"
        ErrAccesDenied           ErrTag = "access-denied"
        ErrLockDenied            ErrTag = "lock-denied"
        ErrResourceDenied        ErrTag = "resource-denied"
        ErrRollbackFailed        ErrTag = "rollback-failed"
        ErrDataExists            ErrTag = "data-exists"
        ErrDataMissing           ErrTag = "data-missing"
        ErrOperationNotSupported ErrTag = "operation-not-supported"
        ErrOperationFailed       ErrTag = "operation-failed"
        ErrPartialOperation      ErrTag = "partial-operation"
        ErrMalformedMessage      ErrTag = "malformed-message"
)

type RPCError struct {
        Type     ErrType     `xml:"error-type"`
        Tag      ErrTag      `xml:"error-tag"`
        Severity ErrSeverity `xml:"error-severity"`
        AppTag   string      `xml:"error-app-tag,omitempty"`
        Path     string      `xml:"error-path,omitempty"`
        Message  string      `xml:"error-message,omitempty"`
        Info     RawXML      `xml:"error-info,omitempty"`
}

func (e RPCError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("rpc error: %s", e.Message)
}</span>

type RPCErrors []RPCError

func (errs RPCErrors) Error() string <span class="cov0" title="0">{
        var sb strings.Builder
        for i, err := range errs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteRune('\n')
                }</span>
                <span class="cov0" title="0">sb.WriteString(err.Error())</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}

func (errs RPCErrors) Unwrap() []error <span class="cov0" title="0">{
        boxed := make([]error, len(errs))
        for i, err := range errs </span><span class="cov0" title="0">{
                boxed[i] = err
        }</span>
        <span class="cov0" title="0">return boxed</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "fmt"
        "strings"
        "time"
)

type ExtantBool bool

func (b ExtantBool) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        if !b </span><span class="cov0" title="0">{
                return nil
        }</span>
        // This produces a empty start/end tag (i.e &lt;tag&gt;&lt;/tag&gt;) vs a self-closing
        // tag (&lt;tag/&gt;() which should be the same in XML, however I know certain
        // vendors may have issues with this format. We may have to process this
        // after xml encoding.
        //
        // See https://github.com/golang/go/issues/21399
        // or https://github.com/golang/go/issues/26756 for a different hack.
        <span class="cov8" title="1">return e.EncodeElement(struct{}{}, start)</span>
}

func (b *ExtantBool) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error <span class="cov8" title="1">{
        v := &amp;struct{}{}
        if err := d.DecodeElement(v, &amp;start); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*b = v != nil
        return nil</span>
}

type OKResp struct {
        OK ExtantBool `xml:"ok"`
}

type Datastore string

func (s Datastore) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("datastores cannot be empty")
        }</span>

        // XXX: it would be nice to actually just block names with crap in them
        // instead of escaping them, but we need to find a list of what is allowed
        // in an xml tag.
        <span class="cov8" title="1">escaped, err := escapeXML(string(s))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid string element: %w", err)
        }</span>

        <span class="cov8" title="1">v := struct {
                Elem string `xml:",innerxml"`
        }{Elem: "&lt;" + escaped + "/&gt;"}
        return e.EncodeElement(&amp;v, start)</span>
}

func escapeXML(input string) (string, error) <span class="cov8" title="1">{
        buf := &amp;strings.Builder{}
        if err := xml.EscapeText(buf, []byte(input)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}

type URL string

func (u URL) MarshalXML(e *xml.Encoder, start xml.StartElement) error <span class="cov8" title="1">{
        v := struct {
                URL string `xml:"url"`
        }{string(u)}
        return e.EncodeElement(&amp;v, start)
}</span>

/*type RawConfig []byte

func (c RawConfig) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
        var v struct {
                Config struct {
                        Inner []byte `xml:",innerxml"`
                } `xml:"config,"`
        }
        v.Config.Inner = []byte(c)

        return e.EncodeElement(&amp;v, start)
}*/

// XXX: these should be typed?
const (
        // Running configuration datastore. Required by RFC6241
        Running Datastore = "running"

        // Candidate configuration configuration datastore.  Supported with the
        // `:candidate` capability defined in RFC6241 section 8.3
        Candidate Datastore = "candidate"

        // Startup configuration configuration datastore.  Supported with the
        // `:startup` capability defined in RFC6241 section 8.7
        Startup Datastore = "startup" //
)

type getConfigReq struct {
        XMLName xml.Name  `xml:"get-config"`
        Source  Datastore `xml:"source"`
        // Filter
}

type getConfigResp struct {
        XMLName xml.Name `xml:"data"`
        Config  []byte   `xml:",innerxml"`
}

// GetConfig implements the &lt;get-config&gt; rpc operation defined in [RFC6241 7.1].
// `source` is the datastore to query.
//
// [RFC6241 7.1]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.1
func (s *Session) GetConfig(ctx context.Context, source Datastore) ([]byte, error) <span class="cov8" title="1">{
        req := getConfigReq{
                Source: source,
        }
        var resp getConfigResp

        if err := s.Call(ctx, &amp;req, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resp.Config, nil</span>
}

// MergeStrategy defines the strategies for merging configuration in a
// `&lt;edit-config&gt; operation`.
//
// *Note*: in RFC6241 7.2 this is called the `operation` attribute and
// `default-operation` parameter.  Since the `operation` term is already
// overloaded this was changed to `MergeStrategy` for a cleaner API.
type MergeStrategy string

const (
        // MergeConfig configuration elements are merged together at the level at
        // which this specified.  Can be used for config elements as well as default
        // defined with [WithDefaultMergeStrategy] option.
        MergeConfig MergeStrategy = "merge"

        // ReplaceConfig defines that the incoming config change should replace the
        // existing config at the level which it is specified.  This can be
        // specified on individual config elements or set as the default strategy set
        // with [WithDefaultMergeStrategy] option.
        ReplaceConfig MergeStrategy = "replace"

        // NoMergeStrategy is only used as a default strategy defined in
        // [WithDefaultMergeStrategy].  Elements must specific one of the other
        // strategies with the `operation` Attribute on elements in the `&lt;config&gt;`
        // subtree.  Elements without the `operation` attribute are ignored.
        NoMergeStrategy MergeStrategy = "none"

        // CreateConfig allows a subtree element to be created only if it doesn't
        // already exist.
        // This strategy is only used as the `operation` attribute of
        // a `&lt;config&gt;` element and cannot be used as the default strategy.
        CreateConfig MergeStrategy = "create"

        // DeleteConfig will completely delete subtree from the config only if it
        // already exists.  This strategy is only used as the `operation` attribute
        // of a `&lt;config&gt;` element and cannot be used as the default strategy.
        DeleteConfig MergeStrategy = "delete"

        // RemoveConfig will remove subtree from the config.  If the subtree doesn't
        // exist in the datastore then it is silently skipped.  This strategy is
        // only used as the `operation` attribute of a `&lt;config&gt;` element and cannot
        // be used as the default strategy.
        RemoveConfig MergeStrategy = "remove"
)

// TestStrategy defines the beahvior for testing configuration before applying it in a `&lt;edit-config&gt;` operation.
//
// *Note*: in RFC6241 7.2 this is called the `test-option` parameter. Since the `option` term is already
// overloaded this was changed to `TestStrategy` for a cleaner API.
type TestStrategy string

const (
        // TestThenSet will validate the configuration and only if is is valid then
        // apply the configuration to the datastore.
        TestThenSet TestStrategy = "test-then-set"

        // SetOnly will not do any testing before applying it.
        SetOnly TestStrategy = "set"

        // Test only will validation the incoming configuration and return the
        // results without modifying the underlying store.
        TestOnly TestStrategy = "test-only"
)

// ErrorStrategy defines the behavior when an error is encountered during a `&lt;edit-config&gt;` operation.
//
// *Note*: in RFC6241 7.2 this is called the `error-option` parameter. Since the `option` term is already
// overloaded this was changed to `ErrorStrategy` for a cleaner API.
type ErrorStrategy string

const (
        // StopOnError will about the `&lt;edit-config&gt;` operation on the first error.
        StopOnError ErrorStrategy = "stop-on-error"

        // ContinueOnError will continue to parse the configuration data even if an
        // error is encountered.  Errors are still recorded and reported in the
        // reply.
        ContinueOnError ErrorStrategy = "continue-on-error"

        // RollbackOnError will restore the configuration back to before the
        // `&lt;edit-config&gt;` operation took place.  This requires the device to
        // support the `:rollback-on-error` capabilitiy.
        RollbackOnError ErrorStrategy = "rollback-on-error"
)

type (
        defaultMergeStrategy MergeStrategy
        testStrategy         TestStrategy
        errorStrategy        ErrorStrategy
)

func (o defaultMergeStrategy) apply(req *editConfigReq) <span class="cov8" title="1">{ req.DefaultMergeStrategy = MergeStrategy(o) }</span>
func (o testStrategy) apply(req *editConfigReq)         <span class="cov8" title="1">{ req.TestStrategy = TestStrategy(o) }</span>
func (o errorStrategy) apply(req *editConfigReq)        <span class="cov8" title="1">{ req.ErrorStrategy = ErrorStrategy(o) }</span>

// WithDefaultMergeStrategy sets the default config merging strategy for the
// &lt;edit-config&gt; operation.  Only [Merge], [Replace], and [None] are supported
// (the rest of the strategies are for defining as attributed in individual
// elements inside the `&lt;config&gt;` subtree).
func WithDefaultMergeStrategy(op MergeStrategy) EditConfigOption <span class="cov8" title="1">{ return defaultMergeStrategy(op) }</span>

// WithTestStrategy sets the `test-option` in the `&lt;edit-config&gt;â€œ operation.
// This defines what testing should be done the supplied configuration.  See the
// documentation on [TestStrategy] for details on each strategy.
func WithTestStrategy(op TestStrategy) EditConfigOption <span class="cov8" title="1">{ return testStrategy(op) }</span>

// WithErrorStrategy sets the `error-option` in the `&lt;edit-config&gt;` operation.
// This defines the behavior when errors are encountered applying the supplied
// config.  See [ErrorStrategy] for the available options.
func WithErrorStrategy(opt ErrorStrategy) EditConfigOption <span class="cov8" title="1">{ return errorStrategy(opt) }</span>

type editConfigReq struct {
        XMLName              xml.Name      `xml:"edit-config"`
        Target               Datastore     `xml:"target"`
        DefaultMergeStrategy MergeStrategy `xml:"default-operation,omitempty"`
        TestStrategy         TestStrategy  `xml:"test-option,omitempty"`
        ErrorStrategy        ErrorStrategy `xml:"error-option,omitempty"`
        // either of these two values
        Config interface{} `xml:"config,omitempty"`
        URL    string      `xml:"url,omitempty"`
}

// EditOption is a optional arguments to [Session.EditConfig] method
type EditConfigOption interface {
        apply(*editConfigReq)
}

// EditConfig issues the `&lt;edit-config&gt;` operation defined in [RFC6241 7.2] for
// updating an existing target config datastore.
//
// [RFC6241 7.2]: https://www.rfc-editor.org/rfc/rfc6241.html#section-7.2
func (s *Session) EditConfig(ctx context.Context, target Datastore, config interface{}, opts ...EditConfigOption) error <span class="cov8" title="1">{
        req := editConfigReq{
                Target: target,
        }

        // XXX: Should we use reflect here?
        switch v := config.(type) </span>{
        case string:<span class="cov8" title="1">
                req.Config = struct {
                        Inner []byte `xml:",innerxml"`
                }{Inner: []byte(v)}</span>
        case []byte:<span class="cov8" title="1">
                req.Config = struct {
                        Inner []byte `xml:",innerxml"`
                }{Inner: v}</span>
        case URL:<span class="cov8" title="1">
                req.URL = string(v)</span>
        default:<span class="cov8" title="1">
                req.Config = config</span>
        }

        <span class="cov8" title="1">for _, opt := range opts </span><span class="cov8" title="1">{
                opt.apply(&amp;req)
        }</span>

        <span class="cov8" title="1">var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)</span>
}

type copyConfigReq struct {
        XMLName xml.Name    `xml:"copy-config"`
        Source  interface{} `xml:"source"`
        Target  interface{} `xml:"target"`
}

// CopyConfig issues the `&lt;copy-config&gt;` operation as defined in [RFC6241 7.3]
// for copying an entire config to/from a source and target datastore.
//
// A `&lt;config&gt;` element defining a full config can be used as the source.
//
// If a device supports the `:url` capability than a [URL] object can be used
// for the source or target datastore.
//
// [RFC6241 7.3] https://www.rfc-editor.org/rfc/rfc6241.html#section-7.3
func (s *Session) CopyConfig(ctx context.Context, source, target interface{}) error <span class="cov8" title="1">{
        req := copyConfigReq{
                Source: source,
                Target: target,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type deleteConfigReq struct {
        XMLName xml.Name  `xml:"delete-config"`
        Target  Datastore `xml:"target"`
}

func (s *Session) DeleteConfig(ctx context.Context, target Datastore) error <span class="cov8" title="1">{
        req := deleteConfigReq{
                Target: target,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type lockReq struct {
        XMLName xml.Name
        Target  Datastore `xml:"target"`
}

func (s *Session) Lock(ctx context.Context, target Datastore) error <span class="cov8" title="1">{
        req := lockReq{
                XMLName: xml.Name{Local: "lock"},
                Target:  target,
        }
        var resp OKResp

        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

func (s *Session) Unlock(ctx context.Context, target Datastore) error <span class="cov8" title="1">{
        req := lockReq{
                XMLName: xml.Name{Local: "unlock"},
                Target:  target,
        }
        var resp OKResp

        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

func (s *Session) Get(ctx context.Context /* filter */) error <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

type killSessionReq struct {
        XMLName   xml.Name `xml:"kill-session"`
        SessionID uint32   `xml:"session-id"`
}

func (s *Session) KillSession(ctx context.Context, sessionID uint32) error <span class="cov8" title="1">{
        req := killSessionReq{
                SessionID: sessionID,
        }
        var resp OKResp

        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type validateReq struct {
        XMLName xml.Name    `xml:"validate"`
        Source  interface{} `xml:"source"`
}

func (s *Session) Validate(ctx context.Context, source interface{}) error <span class="cov8" title="1">{
        req := validateReq{
                Source: source,
        }

        var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)
}</span>

type commitReq struct {
        XMLName        xml.Name   `xml:"commit"`
        Confirmed      ExtantBool `xml:"confirmed,omitempty"`
        ConfirmTimeout int64      `xml:"confirm-timeout,omitempty"`
        Persist        string     `xml:"persist,omitempty"`
        PersistID      string     `xml:"persist-id,omitempty"`
}

// CommitOption is a optional arguments to [Session.Commit] method
type CommitOption interface {
        apply(*commitReq)
}

type confirmed bool
type confirmedTimeout struct {
        time.Duration
}
type persist string
type persistID string

func (o confirmed) apply(req *commitReq) <span class="cov8" title="1">{ req.Confirmed = true }</span>
func (o confirmedTimeout) apply(req *commitReq) <span class="cov8" title="1">{
        req.Confirmed = true
        req.ConfirmTimeout = int64(o.Seconds())
}</span>
func (o persist) apply(req *commitReq) <span class="cov8" title="1">{
        req.Confirmed = true
        req.Persist = string(o)
}</span>
func (o persistID) apply(req *commitReq) <span class="cov8" title="1">{ req.PersistID = string(o) }</span>

// RollbackOnError will restore the configuration back to before the
// `&lt;edit-config&gt;` operation took place.  This requires the device to
// support the `:rollback-on-error` capability.

// WithConfirmed will mark the commits as requiring confirmation or will rollback
// after the default timeout on the device (default should be 600s).  The commit
// can be confirmed with another `&lt;commit&gt;` call without the confirmed option,
// extended by calling with `Commit` With `WithConfirmed` or
// `WithConfirmedTimeout` or canceling the commit with a `CommitCancel` call.
// This requires the device to support the `:confirmed-commit:1.1` capability.
func WithConfirmed() CommitOption <span class="cov8" title="1">{ return confirmed(true) }</span>

// WithConfirmedTimeout is like `WithConfirmed` but using the given timeout
// duration instead of the device's default.
func WithConfirmedTimeout(timeout time.Duration) CommitOption <span class="cov8" title="1">{ return confirmedTimeout{timeout} }</span>

// WithPersist allows you to set a identifier to confirm a commit in another
// sessions.  Confirming the commit requires setting the `WithPersistID` in the
// following `Commit` call matching the id set on the confirmed commit.  Will
// mark the commit as confirmed if not already set.
func WithPersist(id string) CommitOption <span class="cov8" title="1">{ return persist(id) }</span>

// WithPersistID is used to confirm a previous commit set with a given
// identifier.  This allows you to confirm a commit from (potentially) another
// sesssion.
func WithPersistID(id string) persistID <span class="cov8" title="1">{ return persistID(id) }</span>

// Commit will commit a canidate config to the running comming. This requires
// the device to support the `:canidate` capability.
func (s *Session) Commit(ctx context.Context, opts ...CommitOption) error <span class="cov8" title="1">{
        var req commitReq
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt.apply(&amp;req)
        }</span>

        <span class="cov8" title="1">if req.PersistID != "" &amp;&amp; req.Confirmed </span><span class="cov0" title="0">{
                return fmt.Errorf("PersistID cannot be used with Confirmed/ConfirmedTimeout or Persist options")
        }</span>

        <span class="cov8" title="1">var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)</span>
}

// CancelCommitOption is a optional arguments to [Session.CancelCommit] method
type CancelCommitOption interface {
        applyCancelCommit(*cancelCommitReq)
}

func (o persistID) applyCancelCommit(req *cancelCommitReq) <span class="cov8" title="1">{ req.PersistID = string(o) }</span>

type cancelCommitReq struct {
        XMLName   xml.Name `xml:"cancel-commit"`
        PersistID string   `xml:"persist-id,omitempty"`
}

func (s *Session) CancelCommit(ctx context.Context, opts ...CancelCommitOption) error <span class="cov8" title="1">{
        var req cancelCommitReq
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt.applyCancelCommit(&amp;req)
        }</span>

        <span class="cov8" title="1">var resp OKResp
        return s.Call(ctx, &amp;req, &amp;resp)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package netconf

import (
        "context"
        "encoding/xml"
        "errors"
        "fmt"
        "io"
        "log"
        "sync"
        "syscall"

        "github.com/nemith/netconf/transport"
)

type sessionConfig struct {
        capabilities []string
}

type SessionOption interface {
        apply(*sessionConfig)
}

type capabilityOpt []string

func (o capabilityOpt) apply(cfg *sessionConfig) <span class="cov0" title="0">{
        for _, cap := range o </span><span class="cov0" title="0">{
                cfg.capabilities = append(cfg.capabilities, cap)
        }</span>
}

func WithCapability(capabilities ...string) SessionOption <span class="cov0" title="0">{
        return capabilityOpt(capabilities)
}</span>

// Session is represents a netconf session to a one given device.
type Session struct {
        tr        transport.Transport
        sessionID uint64

        clientCaps capabilitySet
        serverCaps capabilitySet

        mu      sync.Mutex
        seq     uint64
        reqs    map[uint64]chan RPCReplyMsg
        closing bool
}

func newSession(transport transport.Transport, opts ...SessionOption) *Session <span class="cov8" title="1">{
        cfg := sessionConfig{
                capabilities: DefaultCapabilities,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt.apply(&amp;cfg)
        }</span>

        <span class="cov8" title="1">s := &amp;Session{
                tr:         transport,
                clientCaps: newCapabilitySet(cfg.capabilities...),
                reqs:       make(map[uint64]chan RPCReplyMsg),
        }
        return s</span>
}

// Open will create a new Session with th=e given transport and open it with the
// necessary hello messages.
func Open(transport transport.Transport, opts ...SessionOption) (*Session, error) <span class="cov0" title="0">{
        s := newSession(transport, opts...)

        // this needs a timeout of some sort.
        if err := s.handshake(); err != nil </span><span class="cov0" title="0">{
                s.tr.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">go s.recv()
        return s, nil</span>
}

// handshake exchanges handshake messages and reports if there are any errors.
func (s *Session) handshake() error <span class="cov8" title="1">{
        clientMsg := HelloMsg{
                Capabilities: s.clientCaps.All(),
        }
        if err := s.writeMsg(&amp;clientMsg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write hello message: %w", err)
        }</span>

        <span class="cov8" title="1">r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // TODO: capture this error some how (ah defer and errors)
        <span class="cov8" title="1">defer r.Close()

        var serverMsg HelloMsg
        if err := xml.NewDecoder(r).Decode(&amp;serverMsg); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to read server hello message: %w", err)
        }</span>

        <span class="cov8" title="1">if serverMsg.SessionID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("server did not return a session-id")
        }</span>

        <span class="cov8" title="1">if len(serverMsg.Capabilities) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("server did not return any capabilities")
        }</span>

        <span class="cov8" title="1">s.serverCaps = newCapabilitySet(serverMsg.Capabilities...)
        s.sessionID = serverMsg.SessionID

        // upgrade the transport if we are on a larger version and the transport
        // supports it.
        const baseCap11 = baseCap + ":1.1"
        if s.serverCaps.Has(baseCap11) &amp;&amp; s.clientCaps.Has(baseCap11) </span><span class="cov0" title="0">{
                if upgrader, ok := s.tr.(interface{ Upgrade() }); ok </span><span class="cov0" title="0">{
                        upgrader.Upgrade()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SessionID returns the current session ID exchanged in the hello messages.
// Will return 0 if there is no session ID.
func (s *Session) SessionID() uint64 <span class="cov8" title="1">{
        return s.sessionID
}</span>

// ClientCapabilities will return the capabilities initialized with the session.
func (s *Session) ClientCapabilities() []string <span class="cov0" title="0">{
        return s.clientCaps.All()
}</span>

// ServerCapabilities will return the capabilities returned by the server in
// it's hello message.
func (s *Session) ServerCapabilities() []string <span class="cov0" title="0">{
        return s.serverCaps.All()
}</span>

// startElement will walk though a xml.Decode until it finds a start element
// and returns it.
func startElement(d *xml.Decoder) (*xml.StartElement, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                tok, err := d.Token()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if start, ok := tok.(xml.StartElement); ok </span><span class="cov8" title="1">{
                        return &amp;start, nil
                }</span>
        }
}

func (s *Session) recvMsg() error <span class="cov8" title="1">{
        r, err := s.tr.MsgReader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer r.Close()
        dec := xml.NewDecoder(r)

        root, err := startElement(dec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">const ncNamespace = "urn:ietf:params:xml:ns:netconf:base:1.0"

        switch root.Name </span>{
        /* Not supported yet. Will implement post beta release
        case "notification":
                var notif NotificationMsg
                if err := dec.DecodeElement(&amp;notif, root); err != nil {
                        log.Printf("failed to decode notification message: %v", err)
                }
        */
        case xml.Name{Space: ncNamespace, Local: "rpc-reply"}:<span class="cov8" title="1">
                var reply RPCReplyMsg
                if err := dec.DecodeElement(&amp;reply, root); err != nil </span><span class="cov0" title="0">{
                        // What should we do here?  Kill the connection?
                        log.Printf("failed to decode rpc-reply message: %v", err)
                }</span>
                <span class="cov8" title="1">ok, ch := s.replyChan(reply.MessageID)
                if !ok </span><span class="cov0" title="0">{
                        // XXX: what should we do here?  Kill the connection?
                        log.Printf("cannot find reply channel for message-id %d", reply.MessageID)
                }</span>
                <span class="cov8" title="1">ch &lt;- reply</span>
        default:<span class="cov0" title="0">
                // XXX: should we die here?
                log.Printf("improper xml message type %q", root.Name.Local)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// recv is the main receive loop.  It runs concurrently to be able to handle
// interleaved messages (like notifications).
func (s *Session) recv() <span class="cov8" title="1">{
        var err error
        for </span><span class="cov8" title="1">{
                if err = s.recvMsg(); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">s.mu.Lock()
        defer s.mu.Unlock()

        // Close all outstanding requests
        for _, ch := range s.reqs </span><span class="cov0" title="0">{
                close(ch)
        }</span>

        <span class="cov0" title="0">if err == io.EOF || err == io.ErrUnexpectedEOF </span><span class="cov0" title="0">{
                if s.closing </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // XXX: This isn't right either.
        <span class="cov0" title="0">log.Fatal(err)</span>
}

func (s *Session) replyChan(msgID uint64) (bool, chan RPCReplyMsg) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        ch, ok := s.reqs[msgID]
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">delete(s.reqs, msgID)
        return true, ch</span>
}

func (s *Session) writeMsg(v interface{}) error <span class="cov8" title="1">{
        w, err := s.tr.MsgWriter()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := xml.NewEncoder(w).Encode(v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return w.Close()</span>
}

func (s *Session) send(msg *RPCMsg) (chan RPCReplyMsg, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.seq++
        msg.MessageID = s.seq

        if err := s.writeMsg(msg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // cap of 1 makes sure we don't block on send
        <span class="cov8" title="1">ch := make(chan RPCReplyMsg, 1)
        s.reqs[msg.MessageID] = ch

        return ch, nil</span>
}

// Do issues a low level RPC call taking in a full RPCMsg and returning the full
// RPCReplyMsg.  In most cases `Session.Call` will do what you want handling
// errors and marshaling/unmarshaling your data.`
func (s *Session) Do(ctx context.Context, msg *RPCMsg) (*RPCReplyMsg, error) <span class="cov8" title="1">{
        ch, err := s.send(msg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">select </span>{
        case reply, ok := &lt;-ch:<span class="cov8" title="1">
                if !ok </span><span class="cov0" title="0">{
                        // XXX: What error should be returned from here if the channel is closed
                        return nil, io.EOF
                }</span>
                <span class="cov8" title="1">return &amp;reply, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                // remove any existing request
                s.mu.Lock()
                delete(s.reqs, msg.MessageID)
                s.mu.Unlock()

                return nil, ctx.Err()</span>

                // XXX: stop channel on close?
        }
}

// Call issues a rpc call for the given NETCONF operation and unmarshaling the
// response into `resp`.
func (s *Session) Call(ctx context.Context, op interface{}, resp interface{}) error <span class="cov8" title="1">{
        msg := &amp;RPCMsg{
                Operation: op,
        }

        reply, err := s.Do(ctx, msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // return rpc errors if we have them
        <span class="cov8" title="1">switch </span>{
        case len(reply.Errors) == 1:<span class="cov0" title="0">
                return reply.Errors[0]</span>
        case len(reply.Errors) &gt; 1:<span class="cov0" title="0">
                return reply.Errors</span>
        }

        // unmarshal the body
        <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                if err = xml.Unmarshal(reply.Body, resp); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Close will gracefully close the sessions first by sending a `close-session`
// operation to the remote and then closing the underlying transport
func (s *Session) Close(ctx context.Context) error <span class="cov0" title="0">{
        s.mu.Lock()
        s.closing = true
        s.mu.Unlock()

        type closeSession struct {
                XMLName xml.Name `xml:"close-session"`
        }

        // This may fail so save the error but still close the underlying transport.
        rpcErr := s.Call(ctx, &amp;closeSession{}, nil)

        // Close the connection and ignore errors if the remote side hung up first.
        if err := s.tr.Close(); err != nil &amp;&amp;
                !errors.Is(err, io.EOF) &amp;&amp;
                !errors.Is(err, syscall.EPIPE) </span><span class="cov0" title="0">{
                </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if rpcErr != io.EOF </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package transport

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"
)

// ErrMalformedChunk represents a message that invalid as defined in the chunk
// framing in RFC6242
var ErrMalformedChunk = errors.New("netconf: invalid chunk")

type frameReader interface {
        io.ReadCloser
        io.ByteReader
}

type frameWriter interface {
        io.WriteCloser
        isClosed() bool
}

// Framer is a wrapper used for transports that implement the framing defined in
// RFC6242.  This supports End-of-Message and Chucked framing methods and
// will move from End-of-Message to Chunked framing after the `Upgrade` method
// has been called.
//
// This is not a transport on it's own (missing the `Close` method) and is
// intended to be embedded into other transports.
type Framer struct {
        r io.Reader
        w io.Writer

        br *bufio.Reader
        bw *bufio.Writer

        curReader frameReader
        curWriter frameWriter

        upgraded bool
}

// NewFramer return a new Framer to be used against the given io.Reader and io.Writer.
func NewFramer(r io.Reader, w io.Writer) *Framer <span class="cov0" title="0">{
        f := &amp;Framer{
                r:  r,
                w:  w,
                br: bufio.NewReader(r),
                bw: bufio.NewWriter(w),
        }

        capDir := os.Getenv("GONETCONF_FRAMED_CAPDIR")
        if capDir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(capDir, 0o755); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("GO_NETCONF_FRAMER: failed to create capture output dir: %v", err))</span>
                }

                <span class="cov0" title="0">ts := time.Now().Format(time.RFC3339)

                inFilename := filepath.Join(capDir, ts+".in")
                inf, err := os.Create(inFilename)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to create capture file %q: %v", inFilename, err))</span>
                }

                <span class="cov0" title="0">outFilename := filepath.Join(capDir, ts+".out")
                outf, err := os.Create(outFilename)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to create capture file %q: %v", inFilename, err))</span>
                }

                <span class="cov0" title="0">f.DebugCapture(inf, outf)</span>
        }

        <span class="cov0" title="0">return f</span>
}

// DebugCapture will copy all *framed* input/output to the the given
// `io.Writers` for sent or recv data.  Either sent of recv can be nil to not
// capture any data.  Useful for displaying to a screen or capturing to a file
// for debugging.
//
// This needs to be called before `MsgReader` or `MsgWriter`.
func (f *Framer) DebugCapture(in io.Writer, out io.Writer) <span class="cov0" title="0">{
        // XXX: should there be a sentinel flag to indicate write/read has been done already?
        if f.curReader != nil ||
                f.curWriter != nil ||
                f.bw.Buffered() &gt; 0 ||
                f.br.Buffered() &gt; 0 </span><span class="cov0" title="0">{
                panic("debug capture added with active reader or writer")</span>
        }

        <span class="cov0" title="0">if out != nil </span><span class="cov0" title="0">{
                f.w = io.MultiWriter(f.w, out)
                f.bw = bufio.NewWriter(f.w)
        }</span>

        <span class="cov0" title="0">if in != nil </span><span class="cov0" title="0">{
                f.r = io.TeeReader(f.r, in)
                f.br = bufio.NewReader(f.r)
        }</span>
}

// Upgrade will cause the Framer to switch from End-of-Message framing to
// Chunked framing.  This is usually called after netconf exchanged the hello
// messages.
func (t *Framer) Upgrade() <span class="cov0" title="0">{
        // XXX: do we need to protect against race conditions (atomic/mutex?)
        t.upgraded = true
}</span>

// MsgReader returns a new io.Reader that is good for reading exactly one netconf
// message.
//
// Only one reader can be used at a time.  When this is called with an existing
// reader then the underlying reader is advanced to the start of the next message
// and invalidates the old reader before returning a new one.
func (t *Framer) MsgReader() (io.ReadCloser, error) <span class="cov0" title="0">{
        if t.upgraded </span><span class="cov0" title="0">{
                t.curReader = &amp;chunkReader{r: t.br}
        }</span> else<span class="cov0" title="0"> {
                t.curReader = &amp;eomReader{r: t.br}
        }</span>
        <span class="cov0" title="0">return t.curReader, nil</span>
}

// MsgWriter returns an io.WriterCloser that is good for writing exactly one
// netconf message.
//
// One one writer can be used at one time and calling this function with an
// existing, unclosed,  writer will result in an error.
func (t *Framer) MsgWriter() (io.WriteCloser, error) <span class="cov0" title="0">{
        if t.curWriter != nil &amp;&amp; !t.curWriter.isClosed() </span><span class="cov0" title="0">{
                return nil, ErrExistingWriter
        }</span>

        <span class="cov0" title="0">if t.upgraded </span><span class="cov0" title="0">{
                t.curWriter = &amp;chunkWriter{w: t.bw}
        }</span> else<span class="cov0" title="0"> {
                t.curWriter = &amp;eomWriter{w: t.bw}
        }</span>
        <span class="cov0" title="0">return t.curWriter, nil</span>
}

var endOfChunks = []byte("\n##\n")

type chunkReader struct {
        r         *bufio.Reader
        chunkLeft int
}

func (r *chunkReader) readHeader() error <span class="cov8" title="1">{
        peeked, err := r.r.Peek(4)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                break</span>
        case io.EOF:<span class="cov8" title="1">
                return io.ErrUnexpectedEOF</span>
        default:<span class="cov0" title="0">
                return err</span>
        }

        <span class="cov8" title="1">if _, err := r.r.Discard(2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // make sure the preamble of `\n#` which is used for both the start of a
        // chuck and the end-of-chunk marker is valid.
        <span class="cov8" title="1">if peeked[0] != '\n' || peeked[1] != '#' </span><span class="cov8" title="1">{
                return ErrMalformedChunk
        }</span>

        // check to see if we are at the end of the read
        <span class="cov8" title="1">if peeked[2] == '#' &amp;&amp; peeked[3] == '\n' </span><span class="cov8" title="1">{
                if _, err := r.r.Discard(2); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return io.EOF</span>
        }

        <span class="cov8" title="1">var n int
        for </span><span class="cov8" title="1">{
                c, err := r.r.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if c == '\n' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        return ErrMalformedChunk
                }</span>
                <span class="cov8" title="1">n = n*10 + int(c) - '0'</span>
        }

        <span class="cov8" title="1">const maxChunk = 4294967295
        if n &lt; 1 || n &gt; maxChunk </span><span class="cov8" title="1">{
                return ErrMalformedChunk
        }</span>

        <span class="cov8" title="1">r.chunkLeft = n
        return nil</span>
}

func (r *chunkReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        // still reading existing chunk
        <span class="cov8" title="1">if r.chunkLeft &lt;= 0 </span><span class="cov8" title="1">{
                if err := r.readHeader(); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">if len(p) &gt; r.chunkLeft </span><span class="cov8" title="1">{
                p = p[:r.chunkLeft]
        }</span>

        <span class="cov8" title="1">n, err := r.r.Read(p)
        r.chunkLeft -= n
        return n, err</span>
}

func (r *chunkReader) ReadByte() (byte, error) <span class="cov8" title="1">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        // still reading existing chunk
        <span class="cov8" title="1">if r.chunkLeft &lt;= 0 </span><span class="cov8" title="1">{
                if err := r.readHeader(); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">r.chunkLeft--
        return b, nil</span>
}

// Close will read the rest of the frame and consume it including
// the end-of-frame markers if we haven't already done so.
func (r *chunkReader) Close() error <span class="cov0" title="0">{
        // poison the reader so that it can no longer be used
        defer func() </span><span class="cov0" title="0">{ r.r = nil }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if r.chunkLeft &lt;= 0 </span><span class="cov0" title="0">{
                        err := r.readHeader()
                        switch err </span>{
                        case nil:<span class="cov0" title="0">
                                break</span>
                        case io.EOF:<span class="cov0" title="0">
                                return nil</span>
                        default:<span class="cov0" title="0">
                                return err</span>
                        }
                }

                <span class="cov0" title="0">if _, err := r.r.Discard(r.chunkLeft); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
}

type chunkWriter struct {
        w *bufio.Writer
}

func (w *chunkWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov8" title="1">if _, err := fmt.Fprintf(w.w, "\n#%d\n", len(p)); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return w.w.Write(p)</span>
}

func (w *chunkWriter) Close() error <span class="cov8" title="1">{
        // poison the writer to prevent writes after close
        defer func() </span><span class="cov8" title="1">{ w.w = nil }</span>()
        <span class="cov8" title="1">if _, err := w.w.Write(endOfChunks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return w.w.Flush()</span>
}

func (w *chunkWriter) isClosed() bool <span class="cov0" title="0">{ return w.w == nil }</span>

var endOfMsg = []byte("]]&gt;]]&gt;")

type eomReader struct {
        r *bufio.Reader
}

func (r *eomReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        // This probably isn't optimal however it looks like xml.Decoder
        // mainly just called ReadByte() and this probably won't ever be
        // used.
        for i := 0; i &lt; len(p); i++ </span><span class="cov8" title="1">{
                b, err := r.ReadByte()
                if err != nil </span><span class="cov8" title="1">{
                        return i, err
                }</span>
                <span class="cov8" title="1">p[i] = b</span>
        }
        <span class="cov0" title="0">return len(p), nil</span>
}

func (r *eomReader) ReadByte() (byte, error) <span class="cov8" title="1">{
        if r.r == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>

        <span class="cov8" title="1">b, err := r.r.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                if err == io.EOF </span><span class="cov8" title="1">{
                        return b, io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return b, err</span>
        }

        // look for the end of the message marker
        <span class="cov8" title="1">if b == endOfMsg[0] </span><span class="cov8" title="1">{
                peeked, err := r.r.Peek(len(endOfMsg) - 1)
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                return 0, io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">return 0, err</span>
                }

                // check if we are at the end of the message
                <span class="cov8" title="1">if bytes.Equal(peeked, endOfMsg[1:]) </span><span class="cov8" title="1">{
                        if _, err := r.r.Discard(len(endOfMsg) - 1); err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>

                        <span class="cov8" title="1">return 0, io.EOF</span>
                }
        }

        <span class="cov8" title="1">return b, nil</span>
}

// Close will read the rest of the frame and consume it including
// the end-of-frame marker.
func (r *eomReader) Close() error <span class="cov0" title="0">{
        // poison the reader so that it can no longer be used
        defer func() </span><span class="cov0" title="0">{ r.r = nil }</span>()

        <span class="cov0" title="0">var err error
        for err == nil </span><span class="cov0" title="0">{
                _, err = r.ReadByte()
                if err == io.EOF </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

type eomWriter struct {
        w *bufio.Writer
}

func (w *eomWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        if w.w == nil </span><span class="cov0" title="0">{
                return 0, ErrInvalidIO
        }</span>
        <span class="cov8" title="1">return w.w.Write(p)</span>
}

func (w *eomWriter) Close() error <span class="cov8" title="1">{
        // poison the writer to prevent writes after close
        defer func() </span><span class="cov8" title="1">{ w.w = nil }</span>()

        <span class="cov8" title="1">if err := w.w.WriteByte('\n'); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := w.w.Write(endOfMsg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return w.w.Flush()</span>
}

func (w *eomWriter) isClosed() bool <span class="cov0" title="0">{ return w.w == nil }</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package ssh

import (
        "context"
        "fmt"
        "io"
        "net"

        "github.com/nemith/netconf/transport"
        "golang.org/x/crypto/ssh"
)

// alias it to a private type so we can make it private when embedding
type framer = transport.Framer //nolint:golint,unused

// Transport implements RFC6242 for implementing NETCONF protocol over SSH.
type Transport struct {
        c     *ssh.Client
        sess  *ssh.Session
        stdin io.WriteCloser

        // indicate that we "own" the client and should close it with the session
        // when the transport is closed.
        ownedClient bool

        *framer
}

// Dial will connect to a ssh server and issues a transport, it's used as a
// convenience function as essentially is the same as
//
//                c, err := ssh.Dial(network, addr, config)
//                 if err != nil { /* ... handle error ... */ }
//                 t, err := NewTransport(c)
//
// When the transport is closed the underlying connection is also closed.
func Dial(ctx context.Context, network, addr string, config *ssh.ClientConfig) (*Transport, error) <span class="cov8" title="1">{
        d := net.Dialer{Timeout: config.Timeout}
        conn, err := d.DialContext(ctx, network, addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sshConn, chans, reqs, err := ssh.NewClientConn(conn, addr, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">client := ssh.NewClient(sshConn, chans, reqs)
        return newTransport(client, true)</span>
}

// NewTransport will create a new ssh transport as defined in RFC6242 for use
// with netconf.  Unlike Dial, the underlying client will not be automatically
// closed when the transport is closed (however any sessions and subsystems
// are still closed).
func NewTransport(client *ssh.Client) (*Transport, error) <span class="cov0" title="0">{
        return newTransport(client, false)
}</span>

func newTransport(client *ssh.Client, owned bool) (*Transport, error) <span class="cov8" title="1">{
        sess, err := client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create ssh session: %w", err)
        }</span>

        <span class="cov8" title="1">w, err := sess.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdin pipe: %w", err)
        }</span>

        <span class="cov8" title="1">r, err := sess.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stdout pipe: %w", err)
        }</span>

        <span class="cov8" title="1">const subsystem = "netconf"
        if err := sess.RequestSubsystem(subsystem); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start netconf ssh subsytem: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Transport{
                c:           client,
                ownedClient: owned,
                sess:        sess,
                stdin:       w,

                framer: transport.NewFramer(r, w),
        }, nil</span>
}

// Close will close the underlying transport.  If the connection was created
// with Dial then then underlying ssh.Client is closed as well.  If not only
// the sessions is closed.
func (t *Transport) Close() error <span class="cov8" title="1">{
        // TODO: in go 1.20 this could easily be an errors.Join() but for now we
        // will save previous errors but try to close everything returning just the
        // "lowest" abstraction layer error
        var retErr error

        if err := t.stdin.Close(); err != nil </span><span class="cov0" title="0">{
                retErr = fmt.Errorf("failed to close ssh stdin: %w", err)
        }</span>

        <span class="cov8" title="1">if err := t.sess.Close(); err != nil </span><span class="cov0" title="0">{
                retErr = fmt.Errorf("failed to close ssh channel: %w", err)
        }</span>

        <span class="cov8" title="1">if t.ownedClient </span><span class="cov8" title="1">{
                if err := t.c.Close(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to close ssh connnection: %w", t.c.Close())
                }</span>
        }

        <span class="cov8" title="1">return retErr</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
